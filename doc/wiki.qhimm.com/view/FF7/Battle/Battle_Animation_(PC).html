<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">
<head>
<title>FF7/Battle/Battle Animation (PC) - QhimmWiki</title>
<meta charset="UTF-8" />
<meta name="generator" content="MediaWiki 1.20.2" />
<link rel="shortcut icon" href="http://wiki.qhimm.com/favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="http://wiki.qhimm.com/opensearch_desc.php" title="QhimmWiki (en)" />
<link rel="EditURI" type="application/rsd+xml" href="http://wiki.qhimm.com/api.php?action=rsd" />
<link rel="copyright" href="http://creativecommons.org/licenses/by-nc-sa/2.5/" />
<link rel="alternate" type="application/atom+xml" title="QhimmWiki Atom feed" href="http://wiki.qhimm.com/index.php?title=Special:RecentChanges&amp;feed=atom" />
<link rel="stylesheet" href="../../../load.php@debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%252Cshared%257Cskins.vector&amp;only=styles&amp;skin=vector&amp;%252A.css" />
<meta name="ResourceLoaderDynamicStyles" content="" />
<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: qhimm_wiki:resourceloader:filter:minify-css:7:9f75cd7a214f5d1850ed6d0df1a4a089 */</style>

<script src="../../../load.php@debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector&amp;%252A"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"FF7/Battle/Battle_Animation_(PC)","wgTitle":"FF7/Battle/Battle Animation (PC)","wgCurRevisionId":3955,"wgArticleId":1323,"wgIsArticle":true,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"FF7/Battle/Battle_Animation_(PC)","wgRestrictionEdit":[],"wgRestrictionMove":[]});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function(){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":1,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"externaldiff":0,"externaleditor":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"quickbar":5,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"showjumplinks":1,"shownumberswatching":1,"showtoc":1,"showtoolbar":1,"skin":"vector","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":0,"watchdefault":0,"watchdeletion":0,"watchlistdays":3,
"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"variant":"en","language":"en","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false});;},{},{});mw.loader.implement("user.tokens",function(){mw.user.tokens.set({"editToken":"+\\","watchToken":false});;},{},{});
/* cache key: qhimm_wiki:resourceloader:filter:minify-js:7:7330ebaa3a8da3f7992caf476ddb8efd */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax"]);
}</script>
<!--[if lt IE 7]><style type="text/css">body{behavior:url("/skins/vector/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-FF7_Battle_Battle_Animation_PC skin-vector action-view vector-animateLayout">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<!-- content -->
		<div id="content" class="mw-body">
			<a id="top"></a>
			<div id="mw-js-message" style="display:none;"></div>
						<!-- firstHeading -->
			<h1 id="firstHeading" class="firstHeading"><span dir="auto">FF7/Battle/Battle Animation (PC)</span></h1>
			<!-- /firstHeading -->
			<!-- bodyContent -->
			<div id="bodyContent">
								<!-- tagline -->
				<div id="siteSub">From QhimmWiki</div>
				<!-- /tagline -->
								<!-- subtitle -->
				<div id="contentSub"><span class="subpages">&lt; <a href="../../FF7.html" title="FF7">FF7</a>&lrm; | <a href="../Battle.1.html" title="FF7/Battle">Battle</a></span></div>
				<!-- /subtitle -->
																<!-- jumpto -->
				<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="Battle_Animation_(PC).html#mw-head">navigation</a>, 					<a href="Battle_Animation_(PC).html#p-search">search</a>
				</div>
				<!-- /jumpto -->
								<!-- bodycontent -->
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><table id="toc" class="toc"><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="Battle_Animation_(PC).html#Battle_Animation_File_Format"><span class="tocnumber">1</span> <span class="toctext">Battle Animation File Format</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="Battle_Animation_(PC).html#Part_I:_Structures"><span class="tocnumber">1.1</span> <span class="toctext">Part I: Structures</span></a>
<ul>
<li class="toclevel-3 tocsection-3"><a href="Battle_Animation_(PC).html#FF7FrameHeader"><span class="tocnumber">1.1.1</span> <span class="toctext">FF7FrameHeader</span></a></li>
<li class="toclevel-3 tocsection-4"><a href="Battle_Animation_(PC).html#FF7FrameMiniHeader"><span class="tocnumber">1.1.2</span> <span class="toctext">FF7FrameMiniHeader</span></a></li>
<li class="toclevel-3 tocsection-5"><a href="Battle_Animation_(PC).html#FF7ShortVec"><span class="tocnumber">1.1.3</span> <span class="toctext">FF7ShortVec</span></a></li>
<li class="toclevel-3 tocsection-6"><a href="Battle_Animation_(PC).html#FF7FrameBuffer"><span class="tocnumber">1.1.4</span> <span class="toctext">FF7FrameBuffer</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-7"><a href="Battle_Animation_(PC).html#Part_II:_Functions_and_Format"><span class="tocnumber">1.2</span> <span class="toctext">Part II: Functions and Format</span></a>
<ul>
<li class="toclevel-3 tocsection-8"><a href="Battle_Animation_(PC).html#GetBitsFixed"><span class="tocnumber">1.2.1</span> <span class="toctext">GetBitsFixed</span></a>
<ul>
<li class="toclevel-4 tocsection-9"><a href="Battle_Animation_(PC).html#A."><span class="tocnumber">1.2.1.1</span> <span class="toctext">A.</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-10"><a href="Battle_Animation_(PC).html#GetDynamicFrameOffsetBits"><span class="tocnumber">1.2.2</span> <span class="toctext">GetDynamicFrameOffsetBits</span></a></li>
<li class="toclevel-3 tocsection-11"><a href="Battle_Animation_(PC).html#GetEncryptedRotationBits"><span class="tocnumber">1.2.3</span> <span class="toctext">GetEncryptedRotationBits</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-12"><a href="Battle_Animation_(PC).html#Part_III:_Putting_it_All_Together"><span class="tocnumber">1.3</span> <span class="toctext">Part III: Putting it All Together</span></a>
<ul>
<li class="toclevel-3 tocsection-13"><a href="Battle_Animation_(PC).html#LoadFrames"><span class="tocnumber">1.3.1</span> <span class="toctext">LoadFrames</span></a></li>
<li class="toclevel-3 tocsection-14"><a href="Battle_Animation_(PC).html#A_Sample_Loop"><span class="tocnumber">1.3.2</span> <span class="toctext">A Sample Loop</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-15"><a href="Battle_Animation_(PC).html#Part_IV:_Qhimm.C3.A2.E2.82.AC.E2.84.A2s_Input"><span class="tocnumber">2</span> <span class="toctext">Part IV: Qhimmâ€™s Input</span></a></li>
</ul>
</td></tr></table>
<h2> <span class="mw-headline" id="Battle_Animation_File_Format"> Battle Animation File Format </span></h2>
<p>File format discovered/decoded by me, L. Spiro.
This file was written by me, L. Spiro, as can be seen by the proper grammar and perfect spelling.
</p><p>(Wiki-fied by Halkun)
(Small additions by Borde)
</p>
<h3> <span class="mw-headline" id="Part_I:_Structures"> Part I: Structures </span></h3>
<p>There are 4 basic structures we will use in decoding the file format.
The header of animation data has been considered to be composed of 3 DWORDâ€™s, 3 WORDâ€™s, and one BYTE, however this is not how the header is really intended to be, despite being aligned correctly.
</p><p>Battle animation files start with a DWORD which tells us how many animations are in the file.  This number includes the special animations which are not actually animations at all.  Although I have not yet decoded them, I suspect these are sets of keys for actual animation sets; keys that call scripted actions or tell the engine to print the damage numbers.
</p>
<h4> <span class="mw-headline" id="FF7FrameHeader"> FF7FrameHeader </span></h4>
<p>Cloudâ€™s battle animation file (rtda) has 94 (0x 5E) animations in it.
After this number begins each animation.
Each animation begins with a 12-byte header (3 DWORDâ€™s) we will call "FF7FrameHeader".
To get from one animation to the next, start at offset 0x04 in the animation file and begin reading these headers.  For each header, skip "FF7FrameHeader.dwChunkSize" bytes until you get to the index of the file you want to load.  When skipping, remember to skip starting at the end of the "FF7FrameHeader" header.
I mentioned a type of special animation data set that is in the header file.
These data sets, when filled with the "FF7FrameHeader" header, will have a "dwChunkSize" less than eleven, we skip them by jumping over the next 8 bytes that follow.
</p><p><br />
First, the two main headers in the animation file.
</p><p>1.
</p>
<code><pre>
typedef struct FF7FrameHeader {
	DWORD		dwBones;		// Bones in the model +	1 (unless we're dealing with a weapon animation, in which case it's value is always 1).	0x00
                                                // This field is rather unreliable so better use the number of bones provided by the skeleton file.
	DWORD		dwFrames;		// Frames in the animation.	0x04
	DWORD		dwChunkSize;	// Size of the animation set.	0x08
} * PFF7FrameHeader;			// Size = 12 bytes.
</pre></code>
<p>2.
</p>
<code><pre>
typedef struct FF7FrameMiniHeader {
	//SHORT		sBones;	// Bones in the animation.
	SHORT		sFrames;// Apparently, frames in the animation (but sometimes sFrames &gt; dwFrames)
	SHORT		sSize;	// Size of the animation data.	0x02
	BYTE		bKey;		// A key flag used for decoding.	0x04
} * PFF7FrameMiniHeader;	// Size = 5 bytes.
</pre></code>
<p>NOTE: sBones should provably be called sFrames since it seems to hold a secondary frames counter. Thus, it should be equal to dwFrames. Unfortunately, it usually isn't. In fact, It's hard to say which one should actually be trusted. Apparently dwFrames is a more conservative value, meaning there will always be at least that many frames in the animation. But there can be more of them. I can't help but wonder if this means the rest of the frames are dummied out information or they serve some sort of purpose. On the other hand, sFrames is sometimes higher than the actual number of frames on the animation chunck. 
</p><p>Anyway, the actual number of frames can be computed by parsing the whole animation chunck.
</p><p>It's also worth mentioning that there is at least one animation (15th from RSAA, the playable frog) which physically lacks the sFrames field. Instead, sSize is at 0x00 and bKey at 0x02. This animation is more than likely damaged, because FF7 doesn't seems to be able to handle it.
</p>
<h4> <span class="mw-headline" id="FF7FrameMiniHeader"> FF7FrameMiniHeader </span></h4>
<p>Most of these members are straight-forward, however there is a very special and VERY important member in the "FF7FrameMiniHeader" structure called "bKey".
This is used for every rotation-decoding scheme (but one).  It determines, essentially, the precision of the rotations and the deltas that follow in successive frames.
The value of â€œbKeyâ€ can only be 0, 2, or 4; the equation "(12 - bKey)" is used to determine the length of each raw (uncompressed) rotation.
After decompression, every rotation must be 12 bits, giving it a range from 0 to 4095.
But if "bKey" is 4, for example, then that means uncompressed rotations are stored as 8 bits, which gives them a range from 0 to 255.  How is this fixed?  After the 8 bits are read, they are then shifted left (up) by "bKey".  This will place them at 12 bits, but with decreased accuracy.
This loss in accuracy is acceptable since rotations work as deltas and usually only change by a small amount.
Most large rotation deltas are things that are spinning, such as the blades on Aero Combatant.  These cases are always a nice round number that can be handled with lower precision (in the case of Aero Combatant, it is 90 degrees even).
</p><p><br />
</p>
<h4> <span class="mw-headline" id="FF7ShortVec"> FF7ShortVec </span></h4>
<p>Now the code to skip to any animation, by index, where "iTarget" is the index.  This code assumes you have already opened the animation file (hFile) and you have skipped pasted the first 4 bytes.
</p>
<code><pre>
FF7FrameHeader	fhHeader;
DWORD			dwBytesRead;
for ( int I = 0; I &lt; iTarget; I++ ) {
	if (&#160;!ReadFile( hFile,
		&amp;fhHeader, sizeof( fhHeader ),
		&amp;dwBytesRead, NULL ) ) {

	CloseHandle( hFile );
	return false;
	}
	if ( fhHeader.dwChunkSize &lt; 11 ) {	// If this is a special
						//	chunk, skip it (it
						//	is counted as part
						//	of the total in the
						//	file).
		if ( SetFilePointer( hFile, 8, NULL, FILE_CURRENT ) ==
		INVALID_SET_FILE_POINTER ) {
			CloseHandle( hFile );
			return false;
		}
		continue;			// Go on to the next
						//	animation.
	}
	// Skip this animation set, whose size is determined by
	//	fhHeader.dwChunkSize.
	if ( SetFilePointer( hFile, fhHeader.dwChunkSize, NULL,
	FILE_CURRENT ) == INVALID_SET_FILE_POINTER ) {
		CloseHandle( hFile );
		return false;
	}
}
// Once we come to this point, we are at the very first byte of the
//	animation we want to load.  Letâ€™s store it into a BYTE array.
if (&#160;!ReadFile( hFile,
	&amp;fhHeader, sizeof( fhHeader ),
	&amp;dwBytesRead, NULL ) ) {

	CloseHandle( hFile );
	return false;
}
BYTE * pbBuffer = new BYTE[fhHeader.dwChunkSize];
// Now pbBuffer holds the actual animation data, including the 5-byte
//	â€œFF7FrameMiniHeaderâ€ header.
</pre></code>
<p>We now have the animation we want loaded into a BYTE array (remember to delete it later).
</p>
<h4> <span class="mw-headline" id="FF7FrameBuffer"> FF7FrameBuffer </span></h4>
<p>Now letâ€™s look at the other structures we will use.
</p><p>3.
</p>
<code><pre>
typedef struct FF7ShortVec {
	SHORT	sX, sY, sZ;		// Signed short versions.	0x00
	INT	iX, iY, iZ;		// Integer representation.	0x06
	FLOAT	fX, fY, fZ;		// Float version after math.	0x12
} * PFF7ShortRot;			// Size = 30 bytes.
</pre></code>
<p>Each rotation goes through 3 forms.  Firstly, everything is stored as 2-byte SHORTâ€™s.  These SHORTâ€™s are stored from 0 to 4096, where 0 = 0 degrees and 4096 = 360 degrees.  This is the equation to convert one of these SHORTâ€™s into degrees: (SHORT / 4096 * 360).  Each frame is based off the previous frame, using the SHORT value as its basis.
Each SHORT is converted to an INT, which is the exact same as the SHORT version, except always positive.
Finally, the FLOAT gets filled with the final value, using the INT version as its base.
So, the sequence is:
</p><p>First frameâ€¦
</p>
<ul><li>Read X bits and store as a signed SHORT.
</li><li>Convert the SHORT to the INT field, adding 0x1000 if negative.
</li><li>Convert to FLOAT using (INT / 4096 * 360).  Apply this FLOAT to your model.
</li></ul>
<p>Next frameâ€¦
</p>
<ul><li>Read X bits, and add them to the SHORT value from last frame.
</li><li>Convert the SHORT to the INT field, adding 0x1000 if negative.
</li><li>Convert to FLOAT using (INT / 4096 * 360).  Apply this FLOAT to your model.
</li></ul>
<p>Repeatâ€¦
</p><p><br />
This structure is for one bone rotation.
To load an entire frameâ€™s work of bones, we need this structure:
4.
</p>
<code><pre>
typedef struct FF7FrameBuffer {
	DWORD			dwBones;
	FF7ShortVec		svPosOffset;
	FF7ShortVec		*psvRots;

	FF7FrameBuffer() {
		dwBones = 0;
		psvRots = NULL;
	}
	~FF7FrameBuffer() {
		dwBones = 0;
		delete [] psvRots;
		psvRots = NULL;
	}

	VOID	SetBones( DWORD dwTotal ) {
		// Delete the old.
		dwBones = 0;
		delete [] psvRots;
		
		// Create the new.
		psvRots = new FF7ShortVec[dwTotal];
		if ( psvRots&#160;!= NULL ) { dwBones = dwTotal; }
	}
} * PFF7FrameBuffer;
</pre></code>
<p>This structure will allocate enough memory for one frame of rotations.  Simply call â€œFF7FrameBuffer.SetBonesâ€ with the number of bones in your animation.
</p><p><br />
</p><p><br />
</p>
<h3> <span class="mw-headline" id="Part_II:_Functions_and_Format"> Part II: Functions and Format </span></h3>
<p>First, we need a way to read bits from the BYTE array we have stored.
This is a basic bit-reading function.  It reads â€œdwTotalBitsâ€ from â€œpbBufferâ€ starting at the â€œdwStartBitâ€â€™th bit.
</p>
<h4> <span class="mw-headline" id="GetBitsFixed"> GetBitsFixed </span></h4>
<p>1.
</p>
<code><pre>
INT GetBitsFixed( BYTE * pbBuffer, DWORD &amp;dwStartBit,
DWORD dwTotalBits ) {
	INT iReturn = 0;

	for ( DWORD I = 0; I &lt; dwTotalBits; I++ ) {
		iReturn &lt;&lt;= 1;

		__asm mov eax, dwStartBit
		__asm mov eax, [eax]
		__asm cdq
		__asm and edx, 7
		__asm add eax, edx
		__asm sar eax, 3
		__asm mov ecx, pbBuffer
		__asm xor edx, edx
		__asm mov dl, byte ptr ds:[ecx+eax]
		__asm mov eax, dwStartBit
		__asm mov ecx, [eax]
		__asm and ecx, 7
		__asm mov eax, 7
		__asm sub eax, ecx
		__asm mov esi, 1
		__asm mov ecx, eax
		__asm shl esi, cl
		__asm and edx, esi
		__asm test edx, edx
		__asm je INCBIT
		iReturn++;
INCBIT:	dwStartBit++;
	}

	// Force the sign bit to extend across the 32-bit boundary.
	iReturn &lt;&lt;= (0x20 - dwTotalBits);
	iReturn &gt;&gt;= (0x20 - dwTotalBits);
	return iReturn;
}
</pre></code>
<p>Now that we can read the bits in the buffer we have made, itâ€™s time to know what weâ€™re doing!
</p>
<h5> <span class="mw-headline" id="A."> A. </span></h5>
<p>The animation data begins with one full frame that is uncompressed, but stored in one of 3 ways.  Every frame after that is compressed, but compressed in one of three ways; one way can be decoded using the same method as on the first frame, which is why sometimes the second, third, and even fourth frames can be decoded using the same method as was used on the first frame.
	First Frame:
Remember that we stored our animation buffer with a 5-byte â€œFF7FrameMiniHeaderâ€ at the beginning of it?  We need this header now!
</p>
<code><pre>
PFF7FrameMiniHeader pfmhMiniHeader = (PFF7FrameMiniHeader)pbBuffer;
</pre></code>
<p>After this cast, â€œpfmhMiniHeader-&gt;bKeyâ€ will contain a number, either 0, 2, or 4.
Each rotation is stored in (12 - â€œpfmhMiniHeader-&gt;bKeyâ€) bits.  This mean either 12, 10, or 8, respectively.
This is important to know.
But first, there is offset data.  Each offset is 16 bits (a signed SHORT).
In the first frame of Cloudâ€™s first animation (rtda), these bytes are 00 00 FE 2E 00 00.
16 bits Ã— 3 = 48 bits, or 6 bytes.
To get these bits, we first need to make a pointer point to the correct location.  â€œpbBufferâ€ points 5 bytes before this data, so letâ€™s make a pointer that points to this data directly.
</p>
<code><pre>
BYTE * pbAnimBuffer = &amp;pbBuffer[5];
</pre></code>
<p>When we use â€œGetBitsFixed()â€ to get the bits.
</p>
<code><pre>
DWORD dwBitStart = 0;	// The bits at which to begin reading in the
//	stream.
SHORT sX = GetBitsFixed( pbAnimBuffer, dwBitStart, 16 );
SHORT sY = GetBitsFixed( pbAnimBuffer, dwBitStart, 16 );
SHORT sZ = GetBitsFixed( pbAnimBuffer, dwBitStart, 16 );
</pre></code>
<p>After doing this, we have each of the three offsets, 0, -466, and 0.
The Y (-466) is always stored as its inverse, but for now we donâ€™t worry about that.
</p><p>The first frame is uncompressed, but it could be 12, 10, or 8 bits per rotation.
How do we know?  â€œpfmhMiniHeader-&gt;bKeyâ€!
</p><p>For each bone, there are 3 rotations.  So, for each bone, we do this:
</p>
<code><pre>
SHORT sRotX = GetBitsFixed( pbAnimBuffer, dwBitStart,
12 - pfmhMiniHeader-&gt;bKey );
SHORT sRotY = GetBitsFixed( pbAnimBuffer, dwBitStart,
12 - pfmhMiniHeader-&gt;bKey );
SHORT sRotZ = GetBitsFixed( pbAnimBuffer, dwBitStart,
12 - pfmhMiniHeader-&gt;bKey );
// We have each rotation, but for the equation to work, the range
//	must always be from 0 to 4095.  If we got 8 bytes, for example,
//	the range would only be from 0 to 255, so here we need to fix
//	this.
sRotX &lt;&lt;= pfmhMiniHeader-&gt;bKey;
sRotY &lt;&lt;= pfmhMiniHeader-&gt;bKey;
sRotZ &lt;&lt;= pfmhMiniHeader-&gt;bKey;
</pre></code>
<p>The first rotation is always 0, 0, 0.  This is the root rotation and is not actually counted as part of the bone network of the character.
</p><p><br />
</p>
<h4> <span class="mw-headline" id="GetDynamicFrameOffsetBits"> GetDynamicFrameOffsetBits </span></h4>
<p>The first frame is easy.
Remember that all frames after are stored as relative offsets from the frame before it.
The offsets are relative to the SHORT values of the previous frame rather than the FLOAT or INT values.
</p><p>Each frame begins with the three position offset values, but in the second frame and after, they can be either 7 or 16 bits.
To determine if which they are, we first get one bit.  If that bit is 0, then the following 7 bits are the actual value of the offset (signed).
If it is 1, then the next 16 bits are the value of the offset.  In total, the offsets will be either 8 or 17 bits.
</p><p>Now the code to perform this operation.
</p><p>2.
</p>
<code><pre>
SHORT GetDynamicFrameOffsetBits( BYTE * pBuffer, DWORD &amp;dwBitStart ) {
DWORD dwFirstByte, dwConsumedBits, dwBitsRemainingToNextByte, dwTemp;
	SHORT sReturn;
	__asm {
		mov eax, dwBitStart
		mov eax, [eax]
		cdq
		and edx, 7
		add eax, edx
		sar eax, 3
		mov dwFirstByte, eax
		mov ecx, dwBitStart
		mov edx, [ecx]
		and edx, 7
		mov dwConsumedBits, edx
		mov eax, 7
		sub eax, dwConsumedBits
		mov dwBitsRemainingToNextByte, eax
		mov ecx, pBuffer
		add ecx, dwFirstByte		// Go to the first byte that
						// has the bit where we
						// want to begin.
		xor edx, edx
		mov dl, byte ptr ds:[ecx]
		shl edx, 8
		mov eax, pBuffer
		add eax, dwFirstByte
		xor ecx, ecx
		mov cl, byte ptr ds:[eax+1]
		or edx, ecx
		mov dwTemp, edx
		mov ecx, dwBitsRemainingToNextByte
		add ecx, 8
		mov edx, 1
		shl edx, cl
		mov eax, dwTemp
		and eax, edx
		test eax, eax
		jnz SeventeenBits

EightBits&#160;:
		mov ecx, dwConsumedBits
		add ecx, 1
		mov edx, dwTemp
		shl edx, cl
		movsx eax, dx
		sar eax, 9
		mov sReturn, ax
		mov ecx, dwBitStart	//
		mov edx, [ecx]		//
		add edx, 8		//
		mov eax, dwBitStart	//
		mov [eax], edx		// Increase dwBitStart by 0x8 (8).
		jmp End

SeventeenBits&#160;:
		mov ecx, dwTemp
		shl ecx, 8
		mov edx, pBuffer
		add edx, dwFirstByte
		xor eax, eax
		mov al, byte ptr ds:[edx+2]
		or ecx, eax
		mov dwTemp, ecx
		mov ecx, dwConsumedBits
		add ecx, 1
		mov edx, dwTemp
		shl edx, cl
		shr edx, 8
		mov sReturn, dx
		mov eax, dwBitStart	//
		mov ecx, [eax]		//
		add ecx, 0x11		//
		mov edx, dwBitStart	//
		mov [edx], ecx		// Increase dwBitStart by 0x11
					//	(17).

End&#160;:
	}
	return sReturn;
}
</pre></code>
<p>After the first frame, we know that the positional offsets immediately follow.
So to get the positional deltas for the next frame, we would do this:
</p>
<code><pre>
SHORT sDeltaX = GetDynamicFrameOffsetBits( pbAnimBuffer, dwBitStart );
SHORT sDeltaY = GetDynamicFrameOffsetBits( pbAnimBuffer, dwBitStart );
SHORT sDeltaZ = GetDynamicFrameOffsetBits( pbAnimBuffer, dwBitStart );
</pre></code>
<p>Now we have the change from the previous frame.  In our â€œFF7ShortVecâ€ structure, these are the SHORT values.  To get the position of this frame, we add these offsets to the last frameâ€™s position.
If â€œIâ€ is this frame and â€œI-1â€ is the last frame, we could do something like this:
</p>
<code><pre>
FF7FrameBuffer[I].svPosOffset.sX = FF7FrameBuffer[I-1].svPosOffset.sX + sX;
FF7FrameBuffer[I].svPosOffset.sY = FF7FrameBuffer[I-1].svPosOffset.sY + sY;
FF7FrameBuffer[I].svPosOffset.sZ = FF7FrameBuffer[I-1].svPosOffset.sZ + sZ;
</pre></code>
<p><br />
</p>
<h4> <span class="mw-headline" id="GetEncryptedRotationBits"> GetEncryptedRotationBits </span></h4>
<p>Now all that is left is to decode the rotations.
Rotations change size in multiple ways.
There is no single simple way to express them.
</p><p>They are, however, always at least one bit long.
The first bit is a flag.  If 0, the rotational change is 0, and that is the end of that rotation.
If it is not 0, then we must get the next 3 bits.
The next 3 bits can tell us to do one of three things.
If the resulting 3-bit signed value is 0, then the rotation delta is (-1 &lt;&lt; pfmhMiniHeader-&gt;bKey).  This is the smallest possible decrement for the given precision (remember that precision is based off â€œpfmhMiniHeader-&gt;bKeyâ€.
If the 3-bit value is 7, then we treat the rotation the same way as we do in the first frame, where we read (12-pfmhMiniHeader-&gt;bKey) bits, then shift left by â€œpfmhMiniHeader-&gt;bKeyâ€.
</p><p>The complicated cases are 1 through 6.
If the 3-bit value is from 1 to 6, then this indicates the number of bits in the rotation delta.
For our example, letâ€™s assume the 3-bit value was 4.
This means we need to read the next 4 bits from the stream.  These 4 bits will be the animation delta, but we actually have to handle them before we can call it final.
The first bit of this new data is a sign bit which determines if the value is below 0.
If it is below zero, we must subtract from that number (1 &lt;&lt; ([Number of Bits] â€“ 1)).
So, if the 3-bit value was 4, and we read 4 bits from the stream, and the resulting value was negative, we would subtract from that value (1 &lt;&lt; 3), or 8.
If the 4-bit value is positive, we add (1 &lt;&lt; ([Number of Bits] â€“ 1)) to it.
After we handle the positive and negative cases, we have to adjust for our precision again.
So, we shift left the resulting value by â€œpfmhMiniHeader-&gt;bKeyâ€.
This is all shown in the code below.
</p><p>3.
</p>
<code><pre>
SHORT GetEncryptedRotationBits( BYTE * pBuffer, DWORD &amp;dwBitStart,
INT iKeyBits ) {
	DWORD dwNumBits, dwType;
	INT iTemp;
	SHORT sReturn;
	// Check the first bit.
	INT iBits = GetBitsFixed( pBuffer, dwBitStart, 1 );
	__asm mov eax, iBits	// If the first bit is 0, return 0
				// and continue. It is not necessary
				// to mov iBits into EAX, but I do it
				// anyway.
	__asm test eax, eax
	__asm jnz SecondTest
	__asm jmp ReturnZero	// Return 0

SecondTest&#160;:
	// Otherwise continue by getting the next 3 bits.
	iBits = GetBitsFixed( pBuffer, dwBitStart, 3 );
	__asm mov eax, iBits
	__asm and eax, 7
	__asm mov dwNumBits, eax
	__asm mov ecx, dwNumBits
	__asm mov dwType, ecx	// dwType = ecx = dwNumBits = eax =
				//	(iBits &amp; 7).
				//	When we get to the case, all of
				//	these values are the same.
	__asm cmp dwType, 7
	__asm ja ReturnZero	// Is dwType above 7?  If so, return 0.
				//	This can never actually happen.

	// Otherwise, use it in a switch case.
	switch ( dwType ) {
		case 0&#160;: {
			__asm or eax, 0xFFFFFFFF	// After this, EAX will
							// always be -1.
			__asm mov ecx, iKeyBits
			__asm shl eax, cl		// Shift left by
							// precision.
							// (-1 &lt;&lt; iKeyBits)
			__asm mov sReturn, ax		// Return that number.
			__asm jmp End
		}
		case 1&#160;: {}
		case 2&#160;: {}
		case 3&#160;: {}
		case 4&#160;: {}
		case 5&#160;: {}
		case 6&#160;: {
			// Get a number of bits equal to the case switch (1,
			// 2, 3, 4, 5, or 6).
			iTemp = GetBitsFixed( pBuffer, dwBitStart,
				dwNumBits );
			__asm mov eax, iTemp
			__asm cmp iTemp, 0
			__asm jl IfLessThanZero
			// If greater than or equal to 0â€¦
			__asm mov ecx, dwNumBits	// dwNumBits = (iBits &amp;
							// 7) from before.
			__asm sub ecx, 1		// dwNumBits - 1.
			__asm mov eax, 1
			__asm shl eax, cl		// (1 &lt;&lt; (dwNumBits â€“
							// 1)).
			__asm mov ecx, iTemp
			__asm add ecx, eax		// iTemp += (1 &lt;&lt;
							// (dwNumBits - 1)).
			__asm mov iTemp, ecx
			__asm jmp AfterTests
			// If less than 0â€¦
IfLessThanZero&#160;:
			__asm mov ecx, dwNumBits	// dwNumBits = (iBits &amp;
							// 7) from before.
			__asm sub ecx, 1		// Decrease it by 1.
			__asm mov edx, 1
			__asm shl edx, cl		// Shift â€œ1â€ left by
							// (dwNumBits - 1).
			__asm mov eax, iTemp		// iTemp still has the
							// bits we read
							// from before.
			__asm sub eax, edx		// iTemp - (1 &lt;&lt;
							// (dwNumBits - 1))
			__asm mov iTemp, eax

			// Now, whatever we set on iTemp, we need to shift it
			// up by the precision value.
AfterTests&#160;:
			__asm mov eax, iTemp
			__asm mov ecx, iKeyBits
			__asm shl eax, cl			// iTemp &lt;&lt;= iKeyBits
			__asm mov sReturn, ax
			__asm jmp End
		}

		case 7&#160;: {
			// Uncompressed bits.  Use standard decoding.
			iTemp = GetBitsFixed( pBuffer, dwBitStart,
				12 - iKeyBits );
			__asm mov ecx, iKeyBits
			__asm shl eax, cl			// iTemp &lt;&lt;= iKeyBits.
			__asm mov sReturn, ax
			__asm jmp End
		}

	}


ReturnZero&#160;:
	__asm xor ax, ax
	__asm mov sReturn, ax

End&#160;:

	return sReturn;
}
</pre></code>
<p><br />
</p>
<h3> <span class="mw-headline" id="Part_III:_Putting_it_All_Together"> Part III: Putting it All Together </span></h3>
<p>To make life easy, letâ€™s use one function to load an entire frame at a time.
This function will load an entire frame into a â€œFF7FrameBufferâ€ structure.
The function will return the bit position where the next frame will begin.
After the function returns, we must translate the rotational INT values to their FLOAT forms (although the function can be modified to do this part itself).
This function will be called in a loop for every frame in the rotation.
</p>
<h4> <span class="mw-headline" id="LoadFrames"> LoadFrames </span></h4>
<p>1.
</p>
<code><pre>
DWORD LoadFrames( PFF7FrameBuffer pfbFrameBuffer,
INT iBones,
INT iBitStart,
BYTE * pbAnimBuffer ) {
	// Get backups of the information we need.
DWORD		dwThisBitStart	= iBitStart;
	INT		iThisBones		= iBones;
	BYTE *	pbThisBuffer	= pbAnimBuffer;

	PFF7FrameMiniHeader pfmhMiniHeader =
		(PFF7FrameMiniHeader)pbAnimBuffer;
	SHORT	sSize = pfmhMiniHeader-&gt;sSize;						
	BYTE	bKeyBits = pfmhMiniHeader-&gt;bKey;

	// Skip the first 5 bytes because they are part of the frame header.
	pbThisBuffer += sizeof( FF7FrameMiniHeader );

	if ( iBitStart == 0 ) {	// First frame?
		// The first frame is uncompressed and each value is the
		// actual rotation.
		pfbFrameBuffer-&gt;svPosOffset.sX = GetBitsFixed( pbThisBuffer, dwThisBitStart, 16 ); //Always 16 bits
		pfbFrameBuffer-&gt;svPosOffset.sY = GetBitsFixed( pbThisBuffer, dwThisBitStart, 16 );
		pfbFrameBuffer-&gt;svPosOffset.sZ = GetBitsFixed( pbThisBuffer, dwThisBitStart, 16 );

		// This function will set the FLOAT values for the
		//	positions.
		// Any scaling that needs to be done would be done here.
		pfbFrameBuffer-&gt;svPosOffset.fX = (FLOAT)pfbFrameBuffer-&gt;svPosOffset.sX;
		pfbFrameBuffer-&gt;svPosOffset.fY = (FLOAT)pfbFrameBuffer-&gt;svPosOffset.sY;
		pfbFrameBuffer-&gt;svPosOffset.fZ = (FLOAT)pfbFrameBuffer-&gt;svPosOffset.sZ;

		for ( int I = 0; I &lt; iThisBones; I++ ) {
			// Now get each bone rotation (the first bone is
			//	actually the root, not part of the skeleton).
			// During the first frame, the rotations are always
			//	(12 â€“ bKeyBits).
			// We shift by bKeyBits to align it to 12 bits.
			pfbFrameBuffer-&gt;psvRots[I].sX = (GetBitsFixed( pbThisBuffer, dwThisBitStart, 12 - bKeyBits ) &lt;&lt; bKeyBits);
			pfbFrameBuffer-&gt;psvRots[I].sY = (GetBitsFixed( pbThisBuffer, dwThisBitStart, 12 - bKeyBits ) &lt;&lt; bKeyBits);
			pfbFrameBuffer-&gt;psvRots[I].sZ = (GetBitsFixed( pbThisBuffer, dwThisBitStart, 12 - bKeyBits ) &lt;&lt; bKeyBits);

			// Store the INT version as the absolute value
			//	of the SHORT version.
			pfbFrameBuffer-&gt;psvRots[I].iX = (pfbFrameBuffer-&gt;psvRots[I].sX &lt; 0)&#160;? pfbFrameBuffer-&gt;psvRots[I].sX + 0x1000&#160;: pfbFrameBuffer-&gt;psvRots[I].sX;
			pfbFrameBuffer-&gt;psvRots[I].iY = (pfbFrameBuffer-&gt;psvRots[I].sY &lt; 0)&#160;? pfbFrameBuffer-&gt;psvRots[I].sY + 0x1000&#160;: pfbFrameBuffer-&gt;psvRots[I].sY;
			pfbFrameBuffer-&gt;psvRots[I].iZ = (pfbFrameBuffer-&gt;psvRots[I].sZ &lt; 0)&#160;? pfbFrameBuffer-&gt;psvRots[I].sZ + 0x1000&#160;: pfbFrameBuffer-&gt;psvRots[I].sZ;
		}
	}
	else {					// All other frames.
		SHORT sX, sY, sZ;			// Get the positional
//	offsets.
		sX = GetDynamicFrameOffsetBits( pbThisBuffer, dwThisBitStart );
		sY = GetDynamicFrameOffsetBits( pbThisBuffer, dwThisBitStart );
		sZ = GetDynamicFrameOffsetBits( pbThisBuffer, dwThisBitStart );

		// When we come to this area of the function,
//	pfbFrameBuffer will have the previous frame
//	still stored in it.  Just add the offsets.
		pfbFrameBuffer-&gt;svPosOffset.sX += sX;
		pfbFrameBuffer-&gt;svPosOffset.sY += sY;
		pfbFrameBuffer-&gt;svPosOffset.sZ += sZ;

		pfbFrameBuffer-&gt;svPosOffset.fX = (FLOAT)pfbFrameBuffer-&gt;svPosOffset.sX;
		pfbFrameBuffer-&gt;svPosOffset.fY = (FLOAT)pfbFrameBuffer-&gt;svPosOffset.sY;
		pfbFrameBuffer-&gt;svPosOffset.fZ = (FLOAT)pfbFrameBuffer-&gt;svPosOffset.sZ;
		for ( int I = 0; I &lt; iThisBones; I++ ) {
			// The same applies here.  Add the offsets
			//	and convert to INT form, adding 0x1000
			//	if it is less than 0.
			// When Final FantasyÂ® VII loads these animations,
			//	it is possible for the value to sneak up above
			//	the 4095 boundary through a series of positive
			//	offsets. 
			sX = GetEncryptedRotationBits( pbThisBuffer, dwThisBitStart, bKeyBits );
			sY = GetEncryptedRotationBits( pbThisBuffer, dwThisBitStart, bKeyBits );
			sZ = GetEncryptedRotationBits( pbThisBuffer, dwThisBitStart, bKeyBits );

			pfbFrameBuffer-&gt;psvRots[I].sX += sX;
			pfbFrameBuffer-&gt;psvRots[I].sY += sY;
			pfbFrameBuffer-&gt;psvRots[I].sZ += sZ;

			pfbFrameBuffer-&gt;psvRots[I].iX = (pfbFrameBuffer-&gt;psvRots[I].sX &lt; 0)&#160;? pfbFrameBuffer-&gt;psvRots[I].sX + 0x1000&#160;: pfbFrameBuffer-&gt;psvRots[I].sX;
			pfbFrameBuffer-&gt;psvRots[I].iY = (pfbFrameBuffer-&gt;psvRots[I].sY &lt; 0)&#160;? pfbFrameBuffer-&gt;psvRots[I].sY + 0x1000&#160;: pfbFrameBuffer-&gt;psvRots[I].sY;
			pfbFrameBuffer-&gt;psvRots[I].iZ = (pfbFrameBuffer-&gt;psvRots[I].sZ &lt; 0)&#160;? pfbFrameBuffer-&gt;psvRots[I].sZ + 0x1000&#160;: pfbFrameBuffer-&gt;psvRots[I].sZ;
		}
	}

	// If we did not read as many bits as there are in the frame,
	//	return the location where the bits should start for the
	//	next frame.
	if ( (SHORT)(dwThisBitStart / 8) &lt; sSize ) {
return dwThisBitStart;
}
	// Otherwise, return 0.
	return 0;
}
</pre></code>
<p>2.
</p>
<h4> <span class="mw-headline" id="A_Sample_Loop"> A Sample Loop </span></h4>
<p>This is an example loop that could be used to load a full animation.
</p>
<code><pre>
FF7FrameHeader fhHeader;
ReadFile( hFile, &amp;fhHeader, sizeof( fhHeader ), &amp;ulBytesRead,
NULL );
BYTE * baData = new BYTE[fhHeader.dwChunkSize];
ReadFile( hFile, &amp;baData, fhHeader.dwChunkSize, &amp;ulBytesRead,
NULL );

	// This will be our buffer to hold one frame.
	//	We will only buffer one frame at a time, so to
	//	to fully load the animations, you would need to
	//	write your own routine to store the data in
	//	fbFrameBuffer after each loaded frame.
FF7FrameBuffer fbFrameBuffer;
fbFrameBuffer.SetBones( fhHeader.dwBones );
INT iBits = 0;
for ( DWORD J = 0; J &lt; fhHeader.dwFrames; J++ ) {
	// We pass a pointer to fbFrameBuffer.  The first frame
	//	will load diretly into it.
	// Every frame after that will actually use it with the
	//	offsets loaded to determine the final result of that
	//	frame. 
		iBits = LoadFrames( &amp;fbFrameBuffer, fhHeader.dwBones, iBits, baData );
		// Reverse the Y offset (required).
		fbFrameBuffer.svPosOffset.fY = 0.0f â€“ fbFrameBuffer.svPosOffset.fY;

// The first rotation set is skipped.  It is not part of
//	the skeleton.  Skipping is optional, but
//	Final FantasyÂ® VII skips it; it is always 0, 0, 0.
// I believe the actual use for the â€œrootâ€ rotation is
//	to dynamically make the model point at its target
//	or face different directions during battle.
// UPDATE: Although the value of this field is 0,0,0 for most animations, some actually store a base rotation here
// so it shouldn't be ignored.
		for ( DWORD I = 0; I &lt; fhHeader.dwBones - 1; I++ ) {
			fbFrameBuffer.psvRots[I+1].fX = (FLOAT)fbFrameBuffer.psvRots[I+1].iX / 4096.0f * 360.0f;
			fbFrameBuffer.psvRots[I+1].fY = (FLOAT)fbFrameBuffer.psvRots[I+1].iY / 4096.0f * 360.0f;
			fbFrameBuffer.psvRots[I+1].fZ = (FLOAT)fbFrameBuffer.psvRots[I+1].iZ / 4096.0f * 360.0f;
		}
// Store the data for this frame here (in your own
//	routine).

	}

	delete [] baData;
</pre></code>
<h2> <span class="mw-headline" id="Part_IV:_Qhimm.C3.A2.E2.82.AC.E2.84.A2s_Input"> Part IV: Qhimmâ€™s Input </span></h2>
<p>Qhimm has taken the time to rewrite two of these functions used in decoding, so it is easier to understand for people who know C++ better than they know assembly (despite my comments being in the assembly code).
He has also written a more in-depth look at the logistics behind the rotation compression format and explains its limitations
</p><p>â€œGetValueFromStreamâ€ is the C/C++ version of my â€œGetDynamicFrameOffsetBitsâ€ and his â€œGetCompressedDeltaFromStreamâ€ is the C++ version of my â€œGetEncryptedRotationBitsâ€.
</p>
<code><pre>
short GetValueFromStream( BYTE *pStreamBytes,
DWORD *pdwStreamBitOffset )
{
	// The return value;
    short sValue;
	// The number of whole bytes already consumed in the stream.
	DWORD dwStreamByteOffset = *pdwStreamBitOffset / 8;
	// The number of bits already consumed in the current stream byte.
	DWORD dwCurrentBitsEaten = *pdwStreamBitOffset&#160;% 8;
	// The distance from dwNextStreamBytes' LSB to the 'type' bit.
	DWORD dwTypeBitShift = 7 - dwCurrentBitsEaten;
	// A copy of the next two bytes in the stream (from big-endian).
	DWORD dwNextStreamBytes = pStreamBytes[dwStreamByteOffset] &lt;&lt; 8 | pStreamBytes[dwStreamByteOffset + 1];

	// Test the first bit (the 'type' bit) to determine the size of the value.
	if (dwNextStreamBytes &amp; (1 &lt;&lt; (dwTypeBitShift + 8)))
	{	// Sixteen-bit value:
		// Collect one more byte from the stream.
		dwNextStreamBytes = dwNextStreamBytes &lt;&lt; 8 |
			pStreamBytes[dwStreamByteOffset + 2];
		// Shift the delta value into place.
		sValue = (dwNextStreamBytes &lt;&lt; (dwCurrentBitsEaten + 1)) &gt;&gt; 8;
		// Update the stream offset.
		*pdwStreamBitOffset += 17;
	}
	else
	{	// Seven-bit value
		// Shift the delta value into place (taking care to preserve the sign).
		sValue = ((short)(dwNextStreamBytes &lt;&lt; (dwCurrentBitsEaten + 1))) &gt;&gt; 9;
		// Update the stream offset.
		*pdwStreamBitOffset += 8;
	}

	// Return the value.
	return sValue;
}


short GetCompressedDeltaFromStream( BYTE *pStreamBytes, DWORD *pdwStreamBitOffset,
int nLoweredPrecisionBits )
{
	unsigned int nBits;
	int iFirstBit = GetBitsFromStream( pStreamBytes, pdwStreamBitOffset, 1 );
	if (iFirstBit)
	{
		unsigned int uType = GetBitsFromStream( pStreamBytes,
			pdwStreamBitOffset, 3 ) &amp; 7;
		switch (uType)
		{
		case 0:
			// Return the smallest possible decrement delta (at given
			//	precision).
			return (-1 &lt;&lt; nLoweredPrecisionBits);

		case 1: case 2: case 3: case 4: case 5: case 6:
			// Read a corresponding number of bits from the stream.
			int iTemp = GetBitsFromStream( pStreamBytes,
				pdwStreamBitOffset, nBits );
			// Transform the value into the full seven-bit value, using the bit
			//	length
			// as part of the encoding scheme (see notes).
			if (iTemp &lt; 0)	iTemp -= 1 &lt;&lt; (nBits - 1);
			else			iTemp += 1 &lt;&lt; (nBits - 1);
			// Adapt to the requested precision and return.
			return (iTemp &lt;&lt; nLoweredPrecisionBits);
		case 7:
			// Read an uncompressed value from the stream (at requested
			//	precision), and return.
			iTemp = GetBitsFromStream( pStreamBytes,
				pdwStreamBitOffset, 12 - nLoweredPrecisionBits );
			return (iTemp &lt;&lt; nLoweredPrecisionBits);
		default:
		}
	}
	// Default/error: return zero.
	return 0;
}


/*
	Notes for rotational delta compression scheme
	=============================================

	The delta values are stored in compressed form in a bit stream. Consecutive
	values share no bit correlation or encoding dependencies, rather they are
	encoded separately using a scheme designed to optimize small-scale rotations.

	Rotations are traditionally given in normalized PSX 4.12 fixed-point compatible
	values, where a full rotation is the integer value 4096. Values above 4095 simply
	map down into the [0,4095] range, as expected from rotational arithmetics. When
	encoded, only the required 12 bits of precision are ever considered.

	In some animations, the author can choose to forcibly lower the precision of
	rotational delta values below 12 bits. Though these animations are naturally not
	as precise, they encode far more efficiently, both because of the smaller size of
	'raw' values, and also because of the increased relative span of the 'close-range'
	encodings available for small deltas. The smallest 128 [-64,63] sizes of deltas
	can be stored in compressed form instead of as raw values. This method is
	efficient
	since a majority of the rotational deltas involved in skeletal character animation
	will be small, and thus doubly effective if used with reduced precision. Precision
	can be reduced by either 2 or 4 bits (down to 10 or 8 bits).

	The encoding scheme is capable of encoding any 12-bit value as follows:

	First, a single bit tells us if the delta is non-zero. If this bit is zero, there
	is no delta value (0) and the decoding is done. Otherwise, a 3 bit integer
	follows, detailing how the delta value is encoded. This has 8 different meanings,
	as follows:

	Type   Meaning
	------ -------------------------------------------------------
	0      The delta is the smallest possible decrement (under the
		current precision)
	1-6    The delta is encoded using this many bytes
	7      The delta is stored in raw form (in the current precision)

	The encoding of small deltas works as follows: The encoded delta can be stored
	using 1-6 bits, giving us a total of 2+4+8+16+32+64 = 126 possible different
	values, which during this explanation will be explained as simple integers (the
	lowest bits of the delta, in current precision). The values 0 (no change) and -1
	(minimal decrement) are already covered, leaving the other 126 values to neatly
	fill out the entire 7 bit range. We do this by encoding each value like follows:

	- The magnitude of the delta is defined as the value of its most significant
	  value bit (in two's complement, so the highest bit not equal to the sign bit).
	  For example, the values '1' and '-2' have magnitude 1, while the value '30' will
	  have a magnitude of 32. For simplicity, we also define the 'signed magnitude' as
	  the magnitude multiplied by the sign of the value (so '-2' has a signed
 	  magnitude of -1).
	- When encoding a value, we subtract its signed magnitude; essentially pushing
	  everything down one notch towards zero, setting the most significant value bit
	  to equal the sign bit and thus ensuring that none of the transformed values
	  require more than six bits to accurately represent in two's complement.
	- The transformed value is then stored starting from its magnitude bit (normally,
	  you would have to start one bit higher to include the sign bit and prevent
 	  signed integer overflow). Small values will be stored using fewer bits, while
 	  larger values use more bits. The two smallest values, 0 and -1, are not
 	  encodeable but are instead handled using the previously mentioned scheme.

	When decoding, you only need to know the number of bits of the encoded value, use
	the value of its most significant bit (not the most significant value bit!) as
	the magnitude, multiply it by the sign of the encoded value to get the signed
	magnitude, and then add that to the encoded value to get the actual delta value.

	Some examples of encodings:

	Delta value *      Encoded            *) in current precision, as integer
	------------------ ------------------
	 0                 0
	-1                 1 000
	-5                 1 011 111
	15                 1 100 0111
	128                1 111 xxxx10000000  (length depends on precision)


	(Note: The reduced precision is treated as rounding towards negative infinity)

*/
</pre></code>

<!-- 
NewPP limit report
Preprocessor visited node count: 205/1000000
Preprocessor generated node count: 404/1000000
Post-expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key qhimm_wiki:pcache:idhash:1323-0!*!*!!en!*!* and timestamp 20160921160606 -->
</div>				<!-- /bodycontent -->
								<!-- printfooter -->
				<div class="printfooter">
				Retrieved from "<a href="http://wiki.qhimm.com/index.php?title=FF7/Battle/Battle_Animation_(PC)&amp;oldid=3955">http://wiki.qhimm.com/index.php?title=FF7/Battle/Battle_Animation_(PC)&amp;oldid=3955</a>"				</div>
				<!-- /printfooter -->
												<!-- catlinks -->
				<div id='catlinks' class='catlinks catlinks-allhidden'></div>				<!-- /catlinks -->
												<div class="visualClear"></div>
				<!-- debughtml -->
								<!-- /debughtml -->
			</div>
			<!-- /bodyContent -->
		</div>
		<!-- /content -->
		<!-- header -->
		<div id="mw-head" class="noprint">
			
<!-- 0 -->
<div id="p-personal" class="">
	<h5>Personal tools</h5>
	<ul>
		<li id="pt-login"><a href="http://wiki.qhimm.com/index.php?title=Special:UserLogin&amp;returnto=FF7%2FBattle%2FBattle+Animation+%28PC%29" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li>
	</ul>
</div>

<!-- /0 -->
			<div id="left-navigation">
				
<!-- 0 -->
<div id="p-namespaces" class="vectorTabs">
	<h5>Namespaces</h5>
	<ul>
					<li  id="ca-nstab-main" class="selected"><span><a href="Battle_Animation_(PC).html"  title="View the content page [c]" accesskey="c">Page</a></span></li>
					<li  id="ca-talk"><span><a href="../../Talk%253AFF7/Battle/Battle_Animation_(PC).html"  title="Discussion about the content page [t]" accesskey="t">Discussion</a></span></li>
			</ul>
</div>

<!-- /0 -->

<!-- 1 -->
<div id="p-variants" class="vectorMenu emptyPortlet">
	<h4>
		</h4>
	<h5><span>Variants</span><a href="Battle_Animation_(PC).html#"></a></h5>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>

<!-- /1 -->
			</div>
			<div id="right-navigation">
				
<!-- 0 -->
<div id="p-views" class="vectorTabs">
	<h5>Views</h5>
	<ul>
					<li id="ca-view" class="selected"><span><a href="Battle_Animation_(PC).html" >Read</a></span></li>
					<li id="ca-viewsource"><span><a href="http://wiki.qhimm.com/edit/FF7/Battle/Battle_Animation_(PC)"  title="This page is protected.&#13;&#10;You can view its source [e]" accesskey="e">View source</a></span></li>
					<li id="ca-history" class="collapsible"><span><a href="http://wiki.qhimm.com/history/FF7/Battle/Battle_Animation_(PC)"  title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>
			</ul>
</div>

<!-- /0 -->

<!-- 1 -->
<div id="p-cactions" class="vectorMenu emptyPortlet">
	<h5><span>Actions</span><a href="Battle_Animation_(PC).html#"></a></h5>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>

<!-- /1 -->

<!-- 2 -->
<div id="p-search">
	<h5><label for="searchInput">Search</label></h5>
	<form action="http://wiki.qhimm.com/index.php" id="searchform">
				<div>
			<input type="search" name="search" title="Search QhimmWiki [f]" accesskey="f" id="searchInput" />			<input type="submit" name="go" value="Go" title="Go to a page with this exact name if exists" id="searchGoButton" class="searchButton" />			<input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton" />					<input type='hidden' name="title" value="Special:Search"/>
		</div>
	</form>
</div>

<!-- /2 -->
			</div>
		</div>
		<!-- /header -->
		<!-- panel -->
			<div id="mw-panel" class="noprint">
				<!-- logo -->
					<div id="p-logo"><a style="background-image: url(../../../skins/wiki.png);" href="../../Main_Page.html"  title="Visit the main page"></a></div>
				<!-- /logo -->
				
<!-- navigation -->
<div class="portal" id='p-navigation'>
	<h5>Navigation</h5>
	<div class="body">
		<ul>
			<li id="n-mainpage-description"><a href="../../Main_Page.html" title="Visit the main page [z]" accesskey="z">Main page</a></li>
			<li id="n-portal"><a href="http://wiki.qhimm.com/view/QhimmWiki:Community_portal" title="About the project, what you can do, where to find things">Community portal</a></li>
			<li id="n-currentevents"><a href="http://wiki.qhimm.com/view/QhimmWiki:Current_events" title="Find background information on current events">Current events</a></li>
			<li id="n-recentchanges"><a href="../../Special%253ARecentChanges.html" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
			<li id="n-randompage"><a href="../../Special%253ARandom.html" title="Load a random page [x]" accesskey="x">Random page</a></li>
			<li id="n-help"><a href="../../Help%253AContents.html" title="The place to find out">Help</a></li>
		</ul>
	</div>
</div>

<!-- /navigation -->

<!-- SEARCH -->

<!-- /SEARCH -->

<!-- TOOLBOX -->
<div class="portal" id='p-tb'>
	<h5>Toolbox</h5>
	<div class="body">
		<ul>
			<li id="t-whatlinkshere"><a href="../../Special%253AWhatLinksHere/FF7/Battle/Battle_Animation_(PC).html" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
			<li id="t-recentchangeslinked"><a href="../../Special%253ARecentChangesLinked/FF7/Battle/Battle_Animation_(PC).html" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
			<li id="t-specialpages"><a href="../../Special%253ASpecialPages.html" title="A list of all special pages [q]" accesskey="q">Special pages</a></li>
			<li id="t-print"><a href="http://wiki.qhimm.com/index.php?title=FF7/Battle/Battle_Animation_(PC)&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>
			<li id="t-permalink"><a href="http://wiki.qhimm.com/index.php?title=FF7/Battle/Battle_Animation_(PC)&amp;oldid=3955" title="Permanent link to this revision of the page">Permanent link</a></li>
		</ul>
	</div>
</div>

<!-- /TOOLBOX -->

<!-- LANGUAGES -->

<!-- /LANGUAGES -->
			</div>
		<!-- /panel -->
		<!-- footer -->
		<div id="footer">
							<ul id="footer-info">
											<li id="footer-info-lastmod"> This page was last modified on 17 December 2012, at 21:37.</li>
											<li id="footer-info-viewcount">This page has been accessed 12,197 times.</li>
											<li id="footer-info-copyright">Content is available under <a class="external" href="http://creativecommons.org/licenses/by-nc-sa/2.5/">Attribution-NonCommercial-ShareAlike</a>.</li>
									</ul>
							<ul id="footer-places">
											<li id="footer-places-privacy"><a href="http://wiki.qhimm.com/view/QhimmWiki:Privacy_policy" title="QhimmWiki:Privacy policy">Privacy policy</a></li>
											<li id="footer-places-about"><a href="http://wiki.qhimm.com/view/QhimmWiki:About" title="QhimmWiki:About">About QhimmWiki</a></li>
											<li id="footer-places-disclaimer"><a href="../../QhimmWiki%253AGeneral_disclaimer.html" title="QhimmWiki:General disclaimer">Disclaimers</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
					<li id="footer-copyrightico">
						<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/"><img src="http://creativecommons.org/images/public/somerights20.gif" alt="Attribution-NonCommercial-ShareAlike" width="88" height="31" /></a>
					</li>
					<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="../../../skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" width="88" height="31" /></a>
					</li>
				</ul>
						<div style="clear:both"></div>
		</div>
		<!-- /footer -->
		<script>if(window.mw){
mw.loader.state({"site":"loading","user":"missing","user.groups":"ready"});
}</script>
<script src="../../../load.php@debug=false&amp;lang=en&amp;modules=skins.vector&amp;only=scripts&amp;skin=vector&amp;%252A"></script>
<script>if(window.mw){
mw.loader.load(["mediawiki.user","mediawiki.page.ready","mediawiki.searchSuggest"], null, true);
}</script>
<script>if(window.mw){
mw.loader.state({"site":"ready"});
}</script>
<!-- Served in 0.123 secs. -->
	</body>
</html>
