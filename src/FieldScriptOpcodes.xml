<?xml version="1.0"?>
<ArrayOfOpcode xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <Opcode>
    <Id>0</Id>
    <Name>RET</Name>
    <LongName>Return from request / Halt</LongName>
    <Description>When an entity's script is being executed as part
    of a request (function call), the return opcode will cause
    current execution to halt and return to whatever the entity was
    previously executing (at some lower priority). If the execution
    was requested via a synchronous call (REQEW or PRQEW), the
    completion of execution is also signalled to the calling entity
    which can resume execution. If return is used when executing at
    base priority, execution will simply halt. This is what happens
    in the entry scripts.</Description>
  </Opcode>
  <Opcode>
    <Id>1</Id>
    <Name>REQ</Name>
    <LongName>Request remote execution (asynchronous,
    non-guaranteed)</LongName>
    <Description>Requests that a remote entity executes one of its
    member functions at a specified priority. The request is
    asynchronous and returns immediately without waiting for the
    remote execution to start or finish. If the specified priority
    is already busy executing, the request will fail
    silently.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>E</Name>
        <Size>8</Size>
        <Description>Entity ID</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>P</Name>
        <Size>3</Size>
        <Description>Priority</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>F</Name>
        <Size>5</Size>
        <Description>Function ID</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>2</Id>
    <Name>REQSW</Name>
    <LongName>Request remote execution (asynchronous execution,
    guaranteed)</LongName>
    <Description>Requests that a remote entity executes one of its
    member functions at a specified priority. If the specified
    priority is already busy executing, the request will block
    until it becomes available and only then return. The remote
    execution is still carried out asynchronously, with no
    notification of completion.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>E</Name>
        <Size>8</Size>
        <Description>Entity ID</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>P</Name>
        <Size>3</Size>
        <Description>Priority</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>F</Name>
        <Size>5</Size>
        <Description>Function ID</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>3</Id>
    <Name>REQEW</Name>
    <LongName>Request remote execution (synchronous,
    guaranteed)</LongName>
    <Description>Requests that a remote entity executes one of its
    member functions at a specified priority. The request will
    block until remote execution has finished before
    returning.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>E</Name>
        <Size>8</Size>
        <Description>Entity ID</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>P</Name>
        <Size>3</Size>
        <Description>Priority</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>F</Name>
        <Size>5</Size>
        <Description>Function ID</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>4</Id>
    <Name>PREQ</Name>
    <LongName>Request party entity execution (asynchronous,
    non-guaranteed)</LongName>
    <Description>Requests that the entity associated with a
    character in the current party executes one of its member
    functions at a specified priority. The request is asynchronous
    and returns immediately without waiting for the remote
    execution to start or finish. If the specified priority is
    already busy executing, the request will fail
    silently.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>PM</Name>
        <Size>8</Size>
        <Description>Party Member ID</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>P</Name>
        <Size>3</Size>
        <Description>Priority</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>F</Name>
        <Size>5</Size>
        <Description>Function ID</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>5</Id>
    <Name>PRQSW</Name>
    <LongName>Request party entity execution (asynchronous
    execution, guaranteed)</LongName>
    <Description>Requests that the entity associated with a
    character in the current party executes one of its member
    functions at a specified priority. If the specified priority is
    already busy executing, the request will block until it becomes
    available and only then return. The remote execution is still
    carried out asynchronously, with no notification of
    completion.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>PM</Name>
        <Size>8</Size>
        <Description>Party Member ID</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>P</Name>
        <Size>3</Size>
        <Description>Priority</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>F</Name>
        <Size>5</Size>
        <Description>Function ID</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>6</Id>
    <Name>PRQEW</Name>
    <LongName>Request party entity execution (asynchronous
    execution, guaranteed)</LongName>
    <Description>Requests that the entity associated with a
    character in the current party executes one of its member
    functions at a specified priority. The request will block until
    remote execution has finished before returning.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>PM</Name>
        <Size>8</Size>
        <Description>Party Member ID</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>P</Name>
        <Size>3</Size>
        <Description>Priority</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>F</Name>
        <Size>5</Size>
        <Description>Function ID</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>7</Id>
    <Name>RETTO</Name>
    <LongName>Return To</LongName>
    <Description>Gives script control to another script within the
    current entity, selected by F.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>P</Name>
        <Size>3</Size>
        <Description>Priority</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>F</Name>
        <Size>5</Size>
        <Description>Function ID</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>8</Id>
    <Name>JOIN</Name>
    <LongName>Party Field Join</LongName>
    <Description>Causes seperated party characters that have
    previously been SPLIT onto the field, to be joined back
    together again; that is, only the party leader becomes visible
    on the field. This should be called if a previous SPLIT has
    completed (the party members have finished speaking, or
    performing their actions, for example). As with SPLIT, the
    speed of the join is specified, from a scale of 1 (almost
    instant) to FF (very slow walk), and must be non-zero. Calling
    JOIN without having previously SPLIT the characters will cause
    the party members to appear at the walkmesh origin and attempt
    to JOIN from there. This is not normally the required behaviour
    and should be avoided.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>S</Name>
        <Size>8</Size>
        <Description>Speed</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>9</Id>
    <Name>SPLIT</Name>
    <LongName>Party Field Split</LongName>
    <Description>Causes the common 'split effect' whereby the
    second and third characters in the current party 'come out'
    from the party leader. That is, they become visible in the
    field, starting from the centre of the party leader, and move
    out to the coordinates specified in the argument list. This is
    commonly used when the other characters in the current party
    have an action or dialog to perform and must be individually
    visible in the field. As well as specifying final coordinates
    for the two other party characters, the directions each
    character faces after the split are specified as a byte, using
    the common direction values found throughout the game. Speed is
    also given and is used to specify the rate at which the
    characters leave the party leader, using a scale from 1 (almost
    instant) to FF (extremely slow walk); this must be
    non-zero.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>XA Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>YA Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B3</Name>
        <Size>4</Size>
        <Description>DA Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B4</Name>
        <Size>4</Size>
        <Description>XB Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B5</Name>
        <Size>4</Size>
        <Description>YB Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B6</Name>
        <Size>4</Size>
        <Description>DB Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>XA</Name>
        <Size>16</Size>
        <Description>X of 2nd character</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>YA</Name>
        <Size>16</Size>
        <Description>Y of 2nd character</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>DA</Name>
        <Size>8</Size>
        <Description>Direction of 2nd character</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>XB</Name>
        <Size>16</Size>
        <Description>X of 3rd character</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>YB</Name>
        <Size>16</Size>
        <Description>Y of 3rd character</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>DB</Name>
        <Size>8</Size>
        <Description>Direction of 3rd character</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>S</Name>
        <Size>8</Size>
        <Description>Speed that the characters split</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>10</Id>
    <Name>SPTYE</Name>
    <LongName>Set Party From Memory</LongName>
    <Description>Sets the current party, using the Character ID
    values found at the banks and addresses specified by the
    arguments. It is possible to retrieve from three different
    banks. This is used to set a party back to the player's
    configuration after a certain event, that requires specific
    characters that have been set using PRTYE, has completed. An
    example would be the party being set to Barret only for the
    Dyne event/battle, and then returning the party back to the
    player's configuration before the Dyne event
    occurs.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>1st character Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>2nd character Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B3</Name>
        <Size>4</Size>
        <Description>3rd characted Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>0</Name>
        <Size>4</Size>
        <Description>Zero</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A1</Name>
        <Size>8</Size>
        <Description>1st character address</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A2</Name>
        <Size>8</Size>
        <Description>2nd character address</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A3</Name>
        <Size>8</Size>
        <Description>3rd character address</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>11</Id>
    <Name>GTPYE</Name>
    <LongName>Get Party To Memory</LongName>
    <Description>Retrieves the current party's Character IDs into
    the banks and addresses specified for each party member. It is
    possible to retrieve values into three different banks, one for
    each member. This is used to store the player's party
    configuration before they are overridden for a special event
    that requires a specific character setup. The player's original
    party configuration can then be set back to its original setup
    using SPTYE.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>1st character Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>2nd character Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B3</Name>
        <Size>4</Size>
        <Description>3rd characted Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>0</Name>
        <Size>4</Size>
        <Description>Zero</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A1</Name>
        <Size>8</Size>
        <Description>1st character address</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A2</Name>
        <Size>8</Size>
        <Description>2nd character address</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A3</Name>
        <Size>8</Size>
        <Description>3rd character address</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>12</Id>
    <Name>(unused)</Name>
    <LongName></LongName>
    <Description></Description>
  </Opcode>
  <Opcode>
    <Id>13</Id>
    <Name>(unused)</Name>
    <LongName></LongName>
    <Description></Description>
  </Opcode>
  <Opcode>
    <Id>14</Id>
    <Name>DSKCG</Name>
    <LongName>Disc Change Screen</LongName>
    <Description>Shows the Disk Change screen if the current disk
    in the drive does not match the argument given. The current
    script is halted until the correct disk is inserted. When the
    correct disk is inserted, the field fades back into view and
    execution continues as normal. If the disk is subsequently
    ejected on this field, the field is instantly hidden, and a
    one-line dialog box is shown asking the user to re-insert the
    disk where it again waits for the disk to be inserted. If a
    disk number outside the range 1 to 4 is specified, an image
    will show, as with normal disk change screens, but no text will
    display to identify which disk to insert.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>D</Name>
        <Size>8</Size>
        <Description>Disk Number</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>15</Id>
    <Name>SPECIAL</Name>
    <LongName>Special Opcode</LongName>
    <Description>Special is a multibyte opcode extension, mostly
    for game specific opcodes to FF7. The first argument specifies
    the type of operation and must be from the values listed below;
    the number of arguments after this must also match the number
    of arguments for the operation type.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>SUBOP</Name>
        <Size>8</Size>
        <Description>Suboperation</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>16</Id>
    <Name>JMPF</Name>
    <LongName>Jump forward</LongName>
    <Description>Jumps forward in the current script a specified
    amount. The jump begins just after the jump opcode itself and
    then skips the specified number of bytes. In the following
    example, the WAIT line is skipped. JMPF (04) WAIT (70,00) SOLID
    (01) If a jump longer than 0xFF is required, use JMPFL
    instead.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Amount to jump forward</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>17</Id>
    <Name>JMPFL</Name>
    <LongName>Jump forward (long)</LongName>
    <Description>Jumps forward in the current script a specified
    amount. The jump begins just after the jump opcode itself and
    then skips the specified number of bytes. Unlike JMPF, this
    jump command allows jumps longer than 0xFF bytes.</Description>
    <Operands>
      <Operand xsi:type="UShort">
        <Name>A</Name>
        <Size>16</Size>
        <Description>Amount to jump forward</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>18</Id>
    <Name>JMPB</Name>
    <LongName>Jump back</LongName>
    <Description>Jumps backward in the current script a specified
    amount. The jump begins just before the jump opcode itself and
    then moves the current byte pointer back the specified number
    of bytes. In the following example, the SOLID and WAIT lines
    are repeated indefinitely. SOLID (01) WAIT (70,00) JMPF (05) If
    a jump longer than 0xFF is required, use JMPBL
    instead.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Amount to jump backward</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>19</Id>
    <Name>JMPBL</Name>
    <LongName>Jump back (long)</LongName>
    <Description>Jumps backward in the current script a specified
    amount. The jump begins just before the jump opcode itself and
    then moves the current byte pointer back the specified number
    of bytes. Unlike JMPB, this jump command allows jumps longer
    than 0xFF bytes.</Description>
    <Operands>
      <Operand xsi:type="UShort">
        <Name>A</Name>
        <Size>16</Size>
        <Description>Amount to jump backward</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>20</Id>
    <Name>IFUB</Name>
    <LongName>If (Unsigned Byte)</LongName>
    <Description>Performs a comparison between a retrieved values
    from memory at specific banks and addresses. If B2 is zero,
    then the value retrieved from bank B1, address A is compared
    with the value specified by V. If B2 is not zero, then the
    value retrieved from bank B1, address A is compared with the
    value retrieved from bank B2, address V. The type of comparison
    used is shown in the table below. If the comparison fails, the
    script pointer jumps forward by the amount specified in the
    final argument; the starting offset for this jump is just
    before the jump value argument itself. This, combined with an
    appropriate jump forward, is used to implement if/else
    functionality in scripts, as demonstrated below. If the content
    of the 'if' block following the IFUB line is longer than 0xFF,
    the jump argument will also need to be longer than 0xFF, and
    hence the IFUBL variant is used instead. If the value to
    compare is larger than 0xFF, the IFUW/IFUWL variants are used.
    If the value being compared is negative, the IFSW/IFSWL
    variants are used. If/Else Example IFUB (10,20,30,02,06) WAIT
    (00,01) JMPF (04) WAIT (00,04) WAIT (00,02) RET () C++ code
    if(&lt;10&gt;[20] &gt; 30) { WAIT(100); } else { WAIT(400); }
    WAIT(200); return;</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>A Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>V Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Address from B1</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>V</Name>
        <Size>8</Size>
        <Description>Value or address from B2</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>C</Name>
        <Size>8</Size>
        <Description>Comparison type : ID Comparison Performed 0 A
        == B 1 A != B 2 A &gt; B 3 A &lt; B 4 A &gt;= B 5 A &lt;= B
        6 A &amp; B 7 A ^ B 8 A | B 9 A &amp; (1&lt;&lt;B) A !((A
        &amp; (1&lt;&lt;B)))</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>E</Name>
        <Size>8</Size>
        <Description>Amount to jump if false</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>21</Id>
    <Name>IFUBL</Name>
    <LongName>If (Unsigned Byte, Long Jump)</LongName>
    <Description>This is similar to the IFUB opcode, but it allows
    a jump of more than 0xFF if the comparison does not hold. This
    opcode is used if the 'if' block will be longer than
    0xFF.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>A Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>V Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Address from B1</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>V</Name>
        <Size>8</Size>
        <Description>Value or address from B2</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>C</Name>
        <Size>8</Size>
        <Description>Comparison type : ID Comparison Performed 0 A
        == B 1 A != B 2 A &gt; B 3 A &lt; B 4 A &gt;= B 5 A &lt;= B
        6 A &amp; B 7 A ^ B 8 A | B 9 A &amp; (1&lt;&lt;B) A !((A
        &amp; (1&lt;&lt;B)))</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>E</Name>
        <Size>16</Size>
        <Description>Amount to jump if false</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>22</Id>
    <Name>IFSW</Name>
    <LongName>If (Signed Word)</LongName>
    <Description>This is similar to the IFUW opcode, but the value
    compared to may be negative.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>A Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>V Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>A</Name>
        <Size>16</Size>
        <Description>Address from B1</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>V</Name>
        <Size>16</Size>
        <Description>Value or address from B2</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>C</Name>
        <Size>8</Size>
        <Description>Comparison type : ID Comparison Performed 0 A
        == B 1 A != B 2 A &gt; B 3 A &lt; B 4 A &gt;= B 5 A &lt;= B
        6 A &amp; B 7 A ^ B 8 A | B 9 A &amp; (1&lt;&lt;B) A !((A
        &amp; (1&lt;&lt;B)))</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>E</Name>
        <Size>8</Size>
        <Description>Amount to jump if false</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>23</Id>
    <Name>IFSWL</Name>
    <LongName>If (Signed Word, Long Jump)</LongName>
    <Description>This is similar to the IFSW opcode in allowing the
    comparison value to be negative, but in addition, allows the
    jump on comparison failure to be longer than 0xFF
    bytes.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>A Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>V Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>A</Name>
        <Size>16</Size>
        <Description>Address from B1</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>V</Name>
        <Size>16</Size>
        <Description>Value or address from B2</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>C</Name>
        <Size>8</Size>
        <Description>Comparison type : ID Comparison Performed 0 A
        == B 1 A != B 2 A &gt; B 3 A &lt; B 4 A &gt;= B 5 A &lt;= B
        6 A &amp; B 7 A ^ B 8 A | B 9 A &amp; (1&lt;&lt;B) A !((A
        &amp; (1&lt;&lt;B)))</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>E</Name>
        <Size>16</Size>
        <Description>Amount to jump if false</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>24</Id>
    <Name>IFUW</Name>
    <LongName>If (Unsigned Word)</LongName>
    <Description>This is similar to the IFUB opcode, but it allows
    the value to be larger than 0xFF.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>A Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>V Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>A</Name>
        <Size>16</Size>
        <Description>Address from B1</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>V</Name>
        <Size>16</Size>
        <Description>Value or address from B2</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>C</Name>
        <Size>8</Size>
        <Description>Comparison type : ID Comparison Performed 0 A
        == B 1 A != B 2 A &gt; B 3 A &lt; B 4 A &gt;= B 5 A &lt;= B
        6 A &amp; B 7 A ^ B 8 A | B 9 A &amp; (1&lt;&lt;B) A !((A
        &amp; (1&lt;&lt;B)))</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>E</Name>
        <Size>8</Size>
        <Description>Amount to jump if false</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>25</Id>
    <Name>IFUWL</Name>
    <LongName>If (Unsigned Word, Long Jump)</LongName>
    <Description>This is similar to the IFUW opcode, but allows for
    a jump on comparison failure of more than 0xFF
    bytes.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>A Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>V Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>A</Name>
        <Size>16</Size>
        <Description>Address from B1</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>V</Name>
        <Size>16</Size>
        <Description>Value or address from B2</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>C</Name>
        <Size>8</Size>
        <Description>Comparison type : ID Comparison Performed 0 A
        == B 1 A != B 2 A &gt; B 3 A &lt; B 4 A &gt;= B 5 A &lt;= B
        6 A &amp; B 7 A ^ B 8 A | B 9 A &amp; (1&lt;&lt;B) A !((A
        &amp; (1&lt;&lt;B)))</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>E</Name>
        <Size>16</Size>
        <Description>Amount to jump if false</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>26</Id>
    <Name>(unused)</Name>
    <LongName></LongName>
    <Description></Description>
  </Opcode>
  <Opcode>
    <Id>27</Id>
    <Name>(unused)</Name>
    <LongName></LongName>
    <Description></Description>
  </Opcode>
  <Opcode>
    <Id>28</Id>
    <Name>(unused)</Name>
    <LongName></LongName>
    <Description></Description>
  </Opcode>
  <Opcode>
    <Id>29</Id>
    <Name>(unused)</Name>
    <LongName></LongName>
    <Description></Description>
  </Opcode>
  <Opcode>
    <Id>30</Id>
    <Name>(unused)</Name>
    <LongName></LongName>
    <Description></Description>
  </Opcode>
  <Opcode>
    <Id>31</Id>
    <Name>(unused)</Name>
    <LongName></LongName>
    <Description></Description>
  </Opcode>
  <Opcode>
    <Id>32</Id>
    <Name>MINIGAME</Name>
    <LongName>Minigame Start</LongName>
    <Description>Begins the minigame as defined by the final byte.
    Once the minigame has completed, the map ID given as the
    argument is loaded and the playable character is moved to the
    XYZ co-ordinates also specified. If an invalid minigame ID is
    passed as the final argument, the return map is loaded
    immediately.</Description>
    <Operands>
      <Operand xsi:type="UShort">
        <Name>M</Name>
        <Size>16</Size>
        <Description>Map ID to return to after game has
        completed</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>X</Name>
        <Size>16</Size>
        <Description>X coordinate of player after game has
        completed</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>Y</Name>
        <Size>16</Size>
        <Description>Y coordinate of player after game has
        completed</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>Z</Name>
        <Size>16</Size>
        <Description>Z coordinate of player after game has
        completed</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>G</Name>
        <Size>8</Size>
        <Description>Game specific value</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>T</Name>
        <Size>8</Size>
        <Description>Minigame type: ID Minigame 0 Bike 1 Chocobo
        Races 2 Snowboard (Icicle version; no music or menu) 3 Fort
        Condor 4 Submarine 5 Speed Square 6 Snowboard (Gold Saucer
        version; music plays and the Retry menu can be
        accessed)</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>33</Id>
    <Name>TUTOR</Name>
    <LongName>Play Tutorial</LongName>
    <Description>Opens the main menu and plays the tutorial
    specified. The tutorial with the given ID must exist in the
    field file (PlayStation) or inside the flevel.lgp archive (PC),
    or the menu will not be closable. On the PlayStation version,
    the tutorials reside after the dialog and AKAO blocks of
    Section 1. On the PC version, the same tutorials can be found
    in this location, but are not used and redundant since the
    dialogs are PlayStation-specific, such as "You'll need a Memory
    Card to save your games". Instead, the PC-specific tutorials
    are used, which are located in the flevel.lgp archive and end
    with the extension .tut.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>T</Name>
        <Size>8</Size>
        <Description>Tutorial ID</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>34</Id>
    <Name>BTMD2</Name>
    <LongName>Battle Mode</LongName>
    <Description>Sets properties for the battle module. The
    argument is a bit field with bits that can be ORd together to
    set multiple battle properties.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>BF1</Name>
        <Size>8</Size>
        <Description>Bit Description (Bit set to 1) 0x80 (10000000)
        Do not display the AP/EXP/Gil/items received screens. 0x40
        (01000000) Activates the battle arena. The next chosen
        BATTLE instead takes place in the arena,but keeping the
        same enemy formation. The "keep going/no way" interface is
        enabled. 0x20 (00100000) Do not play the battle victory
        music. 0x08 (00001000) The party cannot escape the battle.
        0x04 (00000100) Pre-emptive attack. 0x02 (00000010) The
        battle is timed; the player must complete the battle before
        the timer reaches zero, or the battle exits, with no
        AP/EXP/Gil/items received screens displayed.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>BF2</Name>
        <Size>8</Size>
        <Description>Bit Description (Bit set to 1) 0x01 (00000001)
        The party members do not perform their victory celebrations
        at the end of battle.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>BF3</Name>
        <Size>8</Size>
        <Description>Bit Description (Bit set to 1) 0x80 (10000000)
        Disable game over. After a party defeat, the game returns
        to the previous field. 0x01 (00000001) Unknown, but used by
        some fields</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>BF4</Name>
        <Size>8</Size>
        <Description></Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>35</Id>
    <Name>BTRLD</Name>
    <LongName>Battle Result Load</LongName>
    <Description>Stores the result of the last BATTLE to an address
    in memory. The resulting value can then be examined to see what
    the outcome of the battle was.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>Bank to store result (should be a 16bit
        bank)</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Address to store result</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>36</Id>
    <Name>WAIT</Name>
    <LongName>Wait</LongName>
    <Description>Pauses current script execution for a specific
    amount of time. Rather than a specific time value in
    milliseconds/seconds, the amount specifies the number of frames
    that must be drawn before execution resumes. Since the game
    runs at 30fps, WAIT(0x1E) (or WAIT(30) in decimal) will pause
    script execution for 1 second, WAIT(0x96) will pause for 5
    seconds, and so on.</Description>
    <Operands>
      <Operand xsi:type="UShort">
        <Name>A</Name>
        <Size>16</Size>
        <Description>Amount (number of frames) to
        wait.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>37</Id>
    <Name>NFADE</Name>
    <LongName></LongName>
    <Description></Description>
  </Opcode>
  <Opcode>
    <Id>38</Id>
    <Name>BLINK</Name>
    <LongName>Character Blink</LongName>
    <Description>Specifies whether the eyes of the current entity's
    visible object should blink at random intervals. As there is no
    argument to specify which character this refers to, this opcode
    must be placed in the correct character entity's script. To
    open or shut the character's eyes (change the eye texture
    used), use KAWAI.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>S</Name>
        <Size>8</Size>
        <Description>Switch on/off (0/1,
        respectively).</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>39</Id>
    <Name>BGMOVIE</Name>
    <LongName></LongName>
    <Description></Description>
  </Opcode>
  <Opcode>
    <Id>40</Id>
    <Name>KAWAI</Name>
    <LongName>Character Graphics Opcode (Multibyte
    sequence)</LongName>
    <Description>KAWAI is a multipurpose, graphics-related opcode
    that performs a variety of different operations on visible
    entity objects, depending on the subop argument. It was named
    after Final Fantasy VII's Character Programmer, Hiroshi
    Kawai.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>L</Name>
        <Size>8</Size>
        <Description>Total length of the entire opcode and argument
        list.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>S</Name>
        <Size>8</Size>
        <Description>Operation to perform 00 EYETX 01 TRNSP 02
        AMBNT 06 LIGHT 0A SBOBJ 0D SHINE FF RESET</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>41</Id>
    <Name>KAWIW</Name>
    <LongName>Wait For Kawai</LongName>
    <Description>Halts script execution until a prior KAWAI
    operation has completed, such as a LIGHT
    movement.</Description>
  </Opcode>
  <Opcode>
    <Id>42</Id>
    <Name>PMOVA</Name>
    <LongName>Move to Party Member</LongName>
    <Description>Makes the field object/character that the script's
    entity is assigned to, move/walk to the party member specified
    by P. When the object reaches its destination, script execution
    continues.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>P</Name>
        <Size>8</Size>
        <Description>Party member to move towards (0 to
        2).</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>43</Id>
    <Name>SLIP</Name>
    <LongName>Slipability</LongName>
    <Description>If SLIP is set to off, the player will be unable
    to let the playable character run against and along the wall by
    pressing two buttons together. For example, if there is a wall
    beyond the character running left-to-right, and the character
    presses up and right together, the character will normally run
    to the right along the wall. If SLIP is off, the character will
    stop moving until the player presses right by itself; the
    combination of up and right together is disallowed. This is
    sometimes used in areas such as shops. This should be used in
    combination with a LINE to specify the line along which the
    player may not 'slip'.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>S</Name>
        <Size>8</Size>
        <Description>On/off switch (0/1,
        respectively).</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>44</Id>
    <Name>BGPDH</Name>
    <LongName>Background Depth</LongName>
    <Description>Sets the Z-depth for the extra background layer
    specified by L. This opcode will only set the depth of those
    extra layers above the standard background and foreground
    layers (0/1, respectively), and so should be an argument of 2
    or greater.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>4</Size>
        <Description>Bank to retrieve value
        for&#160;D</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>0</Name>
        <Size>4</Size>
        <Description>Zero</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>L</Name>
        <Size>8</Size>
        <Description>ID number of the layer to
        manipulate.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>D</Name>
        <Size>16</Size>
        <Description>Z-depth of the specified layer, or the address
        to find&#160;D&#160;if&#160;B&#160;is
        non-zero.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>45</Id>
    <Name>BGSCR</Name>
    <LongName>Background Scroll</LongName>
    <Description>Scrolls the background layer specified by&#160;L.
    This opcode will only scroll those extra layers above the
    standard background and foreground layers (0/1, respectively),
    and so should be an argument of 2 or greater.
    The&#160;X&#160;and&#160;Y&#160;speeds are signed; positive
    values scroll from right-to-left and bottom-to-top, whilst
    negative values scroll from left-to-right and
    top-to-bottom.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>X Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>Y Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>L</Name>
        <Size>8</Size>
        <Description>ID number of the layer to
        manipulate.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>X</Name>
        <Size>16</Size>
        <Description>Speed of the scroll in the X direction;
        positive values indicate right-to-left
        scrolling.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>Y</Name>
        <Size>16</Size>
        <Description>Speed of the scroll in the Y direction;
        positive values indicate bottom-to-top
        scrolling.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>46</Id>
    <Name>WCLS</Name>
    <LongName></LongName>
    <Description></Description>
  </Opcode>
  <Opcode>
    <Id>47</Id>
    <Name>WSIZW</Name>
    <LongName>Window Resize</LongName>
    <Description>Resizes and/or repositions the window, after it
    has been created with the WINDOW opcode. On the next MESSAGE or
    ASK, the window will be positioned and sized with the new
    properties.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>I</Name>
        <Size>8</Size>
        <Description>WINDOW ID to resize</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>X</Name>
        <Size>16</Size>
        <Description>X-coordinate of the window.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>Y</Name>
        <Size>16</Size>
        <Description>Y-coordinate of the window.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>W</Name>
        <Size>16</Size>
        <Description>Width of the window.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>H</Name>
        <Size>16</Size>
        <Description>Height of the window.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>48</Id>
    <Name>IFKEY</Name>
    <LongName>If Key Pressed</LongName>
    <Description>Checks the status of a button being pressed; if
    pressed, regardless of the previous condition of the button
    press state (see IFKEYON / IFKEYOFF), the "if" body executes
    (that is, the script pointer is moved to the opcode after the
    current IFKEY). If the checked button fails the condition
    check, then the script pointer moves ahead A bytes. The
    highlighted keys in the button ID table below do not quite act
    as the rest when used with this particular opcode. For these
    keys, IFKEY acts in the same manner as IFKEYON; these keys
    cannot be checked repeatedly, and the if statement body will
    only execute once, regardless of whether the key is being held
    down. Button IDs can be ORd with each other to produce a
    combination of keys to check in one statement. For example,
    IFKEY with a key ID of 0x00F0 will check if any of the
    directional buttons are being pressed.</Description>
    <Operands>
      <Operand xsi:type="UShort">
        <Name>B</Name>
        <Size>16</Size>
        <Description>Button Ids to check for: ID Button 0x0001
        Assist 0x0008 Start 0x0010 Up 0x0020 Right 0x0040 Down
        0x0080 Left 0x0100 Camera 0x0200 Target 0x0400 Page Up
        0x0800 Page Down 0x1000 Menu 0x2000 OK 0x4000 Cancel 0x8000
        Switch</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Amount to jump if button not
        pressed.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>49</Id>
    <Name>IFKEYON</Name>
    <LongName>If Key Pressed (First Time)</LongName>
    <Description>Similar to IFKEY, IFKEYON checks if a button is
    being pressed with the given ID (matching those in IFKEY).
    However, the body of the "if" statement only executes if this
    is the first time the button has been recorded as being
    pressed. If this is not the first time it is being pressed
    (that is, the user has held the key down), the condition
    evaluates to false, and the "if" statement body does not
    execute, moving the script pointer forward by A. This is an
    effective way to stop repeatedly executing the body of the "if"
    statement due to the user holding the key down; thus, the body
    of the statement will only execute once. The button state is
    reset when the user lets go of the button, and at this point,
    IFKEYON may evaluate to true once more when the button is
    repressed</Description>
    <Operands>
      <Operand xsi:type="UShort">
        <Name>B</Name>
        <Size>16</Size>
        <Description>Button Ids to check for: ID Button 0x0001
        Assist 0x0008 Start 0x0010 Up 0x0020 Right 0x0040 Down
        0x0080 Left 0x0100 Camera 0x0200 Target 0x0400 Page Up
        0x0800 Page Down 0x1000 Menu 0x2000 OK 0x4000 Cancel 0x8000
        Switch</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Amount to jump if button not
        pressed.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>50</Id>
    <Name>IFKEYOFF</Name>
    <LongName>If Key Lifted</LongName>
    <Description>Similar to IFKEYON. Rather than check if this is
    the first time the user has pressed the button with the given
    ID, IFKEYOFF will not execute the body of the "if" statement
    until the user has lifted the key that was previously held down
    or pressed. This way, the body of the statement will only be
    executed once, when the key is no longer pressed.</Description>
    <Operands>
      <Operand xsi:type="UShort">
        <Name>B</Name>
        <Size>16</Size>
        <Description>Button Ids to check for: ID Button 0x0001
        Assist 0x0008 Start 0x0010 Up 0x0020 Right 0x0040 Down
        0x0080 Left 0x0100 Camera 0x0200 Target 0x0400 Page Up
        0x0800 Page Down 0x1000 Menu 0x2000 OK 0x4000 Cancel 0x8000
        Switch</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Amount to jump if button not
        pressed.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>51</Id>
    <Name>UC</Name>
    <LongName>Character movability</LongName>
    <Description>Disables or enables the movability of the playable
    character, and hides arrows and the hand pointer. If switched
    to off (1), the player cannot move the character using the
    directional buttons until a corresponding UC (0) is called, at
    which point the arrows and hand pointer return.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>S</Name>
        <Size>8</Size>
        <Description>On/off switch (0/1,
        respectively).</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>52</Id>
    <Name>PDIRA</Name>
    <LongName>Face Party Member</LongName>
    <Description>Instantly turns the field object to face the party
    member specified by C. In contrast to PTURA, the turn is not
    gradual, and the parameter is not a party member ID (from 0 for
    the first to 2 for the third in the party), but a Character ID
    (like in MMBud). If the specified character ID is not in your
    party, the field object will turn to the main
    character.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>C</Name>
        <Size>8</Size>
        <Description>Character ID to face.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>53</Id>
    <Name>PTURA</Name>
    <LongName>Turn to Party Member</LongName>
    <Description>Rotates (turns) the field object to face the party
    member specified by P (from 0 to 2), at the speed S. The
    "standard" value for A is 2.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>P</Name>
        <Size>8</Size>
        <Description>Party member to turn towards.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>S</Name>
        <Size>8</Size>
        <Description>Speed of turning; the larger the number, the
        slower the turn.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Larger numbers increase the likelihood that
        the turn will be anticlockwise.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>54</Id>
    <Name>WSPCL</Name>
    <LongName>Window Special (Numerical Display)</LongName>
    <Description>Creates a numerical display inside the given
    window. The display can be either in the form of a clock, or a
    scoreboard with six digits. This only creates the numerical
    display; to actually show it, a MESSAGE or ASK command needs to
    be issued. Using a blank line of dialog will allow you to
    create a numerical display in the top-left of the window
    without field dialog hidden behind it. Alternatively, dialog
    can be shown along with the display by placing the display in
    an appropriate area of the window. To set the time for the
    clock variant, STTIM is used. To set the number for the
    numerical display, WNUMB is used.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>W</Name>
        <Size>8</Size>
        <Description>WINDOW ID to apply the change
        to.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>T</Name>
        <Size>8</Size>
        <Description>Type of display ID Display Type 0 None 1 Clock
        (00:00) 2 Numeric (000000)</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>X</Name>
        <Size>8</Size>
        <Description>X-coordinate of the numerical display,
        relative to the top-left of the window.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>Y</Name>
        <Size>8</Size>
        <Description>Y-coordinate of the numerical display,
        relative to the top-left of the window.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>55</Id>
    <Name>WNUMB</Name>
    <LongName>Set Number</LongName>
    <Description>Sets the numerical display, as found in the WSPCL
    opcode. The number may be set with a specified value or
    retrieved from two 16-bit values, and the number of digits to
    show is specified with C. Unlike the other special window
    setting function, STTIM, the WINDOW ID must be given for this
    opcode. If the value does not fit in the specified number of
    digits for the display, the higher units are not
    displayed.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>Bank to retrieve lower two bytes of number, or
        zero if number is given as a literal value.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>Bank to retrieve higher two bytes of number,
        or zero if number is given as a literal
        value.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>W</Name>
        <Size>8</Size>
        <Description>Window ID whose numerical display will be
        set.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="ULong">
        <Name>N</Name>
        <Size>32</Size>
        <Description>A four-byte number to set the numerical
        display. If B1 or B2 are non-zero, this value is split into
        two two-byte values, indicating the address to find the
        number value in banks B1 and B2,
        respectively.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>C</Name>
        <Size>8</Size>
        <Description>The number of digits to display, from 1 to
        8.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>56</Id>
    <Name>STTIM</Name>
    <LongName>Set Timer</LongName>
    <Description>Sets the clock, as found in the WSPCL opcode. If
    the hours, minutes or seconds are specified in the argument,
    the corresponding B nybble is zero. Otherwise, the value for
    the time component is retrieved from the bank and address
    specified. The seperate time components can be retrieved from
    memory or specified as a value, in the same argument list, as
    demonstrated below. Hours are not directly visible on the
    clock, as it only displays minutes and seconds. Hours are
    translated into minutes, so if you specify one hour, the clock
    displays 60 minutes, and so on.</Description>
  </Opcode>
  <Opcode>
    <Id>57</Id>
    <Name>GOLDu</Name>
    <LongName>Gil Up</LongName>
    <Description>Increases the amount of gil by a constant amount,
    or by an amount found in the source bank B and address A. The
    total gil is capped above by 0xFFFFFFFF; attempts to increment
    further will fail.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>4</Size>
        <Description>A Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>0</Name>
        <Size>4</Size>
        <Description>Zero</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="ULong">
        <Name>A</Name>
        <Size>32</Size>
        <Description>Amount to increase/Address of source in bank
        B</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>58</Id>
    <Name>GOLDd</Name>
    <LongName>Gil Down</LongName>
    <Description>Decreases the amount of gil by a constant amount,
    or by an amount found in the source bank B and address A. The
    total gil is capped below by 0; attempts to decrement further
    will fail.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>4</Size>
        <Description>A Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>0</Name>
        <Size>4</Size>
        <Description>Zero</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="ULong">
        <Name>A</Name>
        <Size>32</Size>
        <Description>Amount to decrease/Address of source in bank
        B</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>59</Id>
    <Name>CHGLD</Name>
    <LongName>Check Gil</LongName>
    <Description>Copies the amount of gil the party has into the
    destination addresses. As the gil amount is a four-byte value,
    the arguments require two destination addresses to place two
    two-byte values into. Address 1 takes the lower two bytes of
    the gil amount, while address 2 takes the higher two
    bytes.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>Destination bank 1</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>Destination bank 2</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A1</Name>
        <Size>8</Size>
        <Description>Destination address 1</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A2</Name>
        <Size>8</Size>
        <Description>Destination address 2</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>60</Id>
    <Name>HMPMAX1</Name>
    <LongName>HP/MP Maximum</LongName>
    <Description>An alias for HMPMAX3.</Description>
  </Opcode>
  <Opcode>
    <Id>61</Id>
    <Name>HMPMAX2</Name>
    <LongName>HP/MP Maximum</LongName>
    <Description>An alias for HMPMAX3.</Description>
  </Opcode>
  <Opcode>
    <Id>62</Id>
    <Name>MHMMX</Name>
    <LongName>All HP/MP Maximum with Status Clear</LongName>
    <Description>Restores full HP and MP of every available
    character, even those outside the current party, as well as
    removing status effects.</Description>
  </Opcode>
  <Opcode>
    <Id>63</Id>
    <Name>HMPMAX3</Name>
    <LongName>HP/MP Maximum</LongName>
    <Description>Restores full HP and MP of every party member, but
    not those outside the current party. It does not remove status
    effects such as Fury or Sadness, but will revive KOd party
    members.</Description>
  </Opcode>
  <Opcode>
    <Id>64</Id>
    <Name>MESSAGE</Name>
    <LongName>Message display</LongName>
    <Description>Displays a dialog in the WINDOW that has
    previously been initialised to display this
    dialog.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>N</Name>
        <Size>8</Size>
        <Description>The ID of the window to use.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>D</Name>
        <Size>8</Size>
        <Description>The zero-based index of the dialog that will
        be displayed.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>65</Id>
    <Name>MPARA</Name>
    <LongName>Message Parameter (8-bit value/address)</LongName>
    <Description>Replaces the Variable Control Code, found in lines
    of dialog, with a specific value. This allows either literal
    values or values retrieved from memory to be displayed in
    message boxes. Message parameters are set, and then the dialog
    with the Variable control codes is displayed using MESSAGE, as
    normal. The ID of the Window must be provided, but this can be
    still be provided before the window has been created using
    WINDOW. For lines of dialog with multiple Variable codes, the I
    argument identifies which code this value should replace,
    starting from zero for the first Variable code found in the
    line of dialog about to be displayed. If B is non-zero, then
    bank B and address V will be accessed to retrieve the value
    that will be used in inserting into the dialog. Otherwise, the
    value provided by V is inserted as-is into the control code.
    Whilst the V argument is one byte, if the address retrieved
    from is a 16-bit bank, a 16-bit value will display. The 8-bit
    nature of this opcode refers solely to the final argument size,
    and the size of the literal that can be specified. If a literal
    of greater than 0xFF is needed, MPRA2 is used
    instead.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>V Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>W</Name>
        <Size>8</Size>
        <Description>WINDOW ID for this parameter.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>I</Name>
        <Size>8</Size>
        <Description>ID of the "Variable" dialog code that this
        value will replace.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>V</Name>
        <Size>8</Size>
        <Description>Value to insert into dialog, or address of
        value, if B is non-zero.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>66</Id>
    <Name>MPRA2</Name>
    <LongName>Message Parameter (16-bit)</LongName>
    <Description>Similar to MPARA, but allows a constant value of
    greater than one byte to be supplied. This does not apply if B
    is non-zero, as the address the value is retrieved from must be
    in the range 0 to 0xFF.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>V Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>W</Name>
        <Size>8</Size>
        <Description>WINDOW ID for this parameter.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>I</Name>
        <Size>8</Size>
        <Description>ID of the "Variable" dialog code that this
        value will replace.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>V</Name>
        <Size>16</Size>
        <Description>Value to insert into dialog, or address of
        value, if B is non-zero.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>67</Id>
    <Name>MPNAM</Name>
    <LongName>Map Name</LongName>
    <Description>Sets the name of this map to the dialog ID given
    by D. The map name is found in the box in the bottom-right of
    the main menu, below the time and gil box.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>D</Name>
        <Size>8</Size>
        <Description>Dialog ID</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>68</Id>
    <Name>(unused)</Name>
    <LongName></LongName>
    <Description></Description>
  </Opcode>
  <Opcode>
    <Id>69</Id>
    <Name>MPu</Name>
    <LongName>MP Up</LongName>
    <Description>Increases the MP of the party member specified by
    P by the amount V. If B is non-zero, then the value to increase
    by is retrieved from bank B and address V.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>V Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>P</Name>
        <Size>8</Size>
        <Description>Party member whose MP will increase (0 to
        2).</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>V</Name>
        <Size>16</Size>
        <Description>Value to increase MP by, or address to
        retrieve value from if B is non-zero.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>70</Id>
    <Name>(unused)</Name>
    <LongName></LongName>
    <Description></Description>
  </Opcode>
  <Opcode>
    <Id>71</Id>
    <Name>MPd</Name>
    <LongName>MP Down</LongName>
    <Description>Decreases the MP of the party member specified by
    P by the amount V. If B is non-zero, then the value to decrease
    by is retrieved from bank B and address V.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>V Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>P</Name>
        <Size>8</Size>
        <Description>Party member whose MP will decrease (0 to
        2).</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>V</Name>
        <Size>16</Size>
        <Description>Value to decrease MP by, or address to
        retrieve value from if B is non-zero.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>72</Id>
    <Name>ASK</Name>
    <LongName>Ask Question</LongName>
    <Description>The ASK command opens a window with a set of
    choices to be picked with the "selector finger". If ASK is
    called on an open window ID, the window will shrink closed and
    re-open with the new data.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>Bank to put line number
        selected.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>W</Name>
        <Size>8</Size>
        <Description>Window ID to place the question in.
        (Initialized with WINDOW)</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>M</Name>
        <Size>8</Size>
        <Description>Which dialog to display from dialog
        table.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>F</Name>
        <Size>8</Size>
        <Description>Line from dialog where the first question
        is.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>L</Name>
        <Size>8</Size>
        <Description>Line from dialog where the last question
        is.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Address in bank where line selected is
        written.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>73</Id>
    <Name>MENU</Name>
    <LongName>Menu</LongName>
    <Description>MENU has two uses. Its primary function is to
    display a menu or other special screen; these menus range from
    the character name entry screen, to a shop, and even the staff
    credit display. The type of display can be found in the first
    table below. The other function is to provide a set of special
    events that would normally be accomplished through a set of
    opcodes, but are instead coded directly into a MENU call. These
    events are provided in the second table. Some types of menu are
    erroneous or produce erratic behaviour, and were most likely
    used for testing. As such, they are not listed
    here.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>P Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>T</Name>
        <Size>8</Size>
        <Description>Type of menu, or special event. ID Menu Type 5
        FF7 Credits 6 Character Name Entry 7 Party Select 8 Shop 9
        Main Menu E Save Screen ID Event Type F Yuffie's Materia
        Steal (Remove All Materia) 12 Remove Cloud's Materia 13
        Restore Cloud's Materia</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>P</Name>
        <Size>8</Size>
        <Description>Parameter to the menu, or address of parameter
        value, if B is non-zero.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>74</Id>
    <Name>MENU2</Name>
    <LongName>Main menu accessibility</LongName>
    <Description>Disables or enables access to the main menu
    through the [MENU] key/button. Transitioning to another field
    will re-enable the menu.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>S</Name>
        <Size>8</Size>
        <Description>On/off switch (0/1,
        respectively).</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>75</Id>
    <Name>BTLTB</Name>
    <LongName>Battle Table</LongName>
    <Description>Switches between the two sets of encounter data
    that may exist in a field file, depending on the ID
    given.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>I</Name>
        <Size>8</Size>
        <Description>ID of the encounter table to use, either 0
        (standard) or 1.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>76</Id>
    <Name>(unused)</Name>
    <LongName></LongName>
    <Description></Description>
  </Opcode>
  <Opcode>
    <Id>77</Id>
    <Name>HPu</Name>
    <LongName>HP Up</LongName>
    <Description>Increases the HP of the party member specified by
    P by the amount V. If B is non-zero, then the value to increase
    by is retrieved from bank B and address V.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>V Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>P</Name>
        <Size>8</Size>
        <Description>Party member whose HP will increase (0 to
        2).</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>V</Name>
        <Size>16</Size>
        <Description>Value to increase HP by, or address to
        retrieve value from if B is non-zero.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>78</Id>
    <Name>(unused)</Name>
    <LongName></LongName>
    <Description></Description>
  </Opcode>
  <Opcode>
    <Id>79</Id>
    <Name>HPd</Name>
    <LongName>HP Down</LongName>
    <Description>Decreases the HP of the party member specified by
    P by the amount V. If B is non-zero, then the value to decrease
    by is retrieved from bank B and address V.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>V Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>P</Name>
        <Size>8</Size>
        <Description>Party member whose HP will decrease (0 to
        2).</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>V</Name>
        <Size>16</Size>
        <Description>Value to decrease HP by, or address to
        retrieve value from if B is non-zero.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>80</Id>
    <Name>WINDOW</Name>
    <LongName>Window creation</LongName>
    <Description>Creates a window with a given ID and
    placement/size parameters. Windows are used to show dialog,
    present choices and so on, each of which reference the window's
    ID to insert text. This command only initializes a window ID,
    but does not present itself until a dialog command is issued on
    it.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>N</Name>
        <Size>8</Size>
        <Description>The numerical ID that the newly-created window
        will be associated with.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>X</Name>
        <Size>16</Size>
        <Description>X-coordinate of the window.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>Y</Name>
        <Size>16</Size>
        <Description>Y-coordinate of the window.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>W</Name>
        <Size>16</Size>
        <Description>Window width.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>H</Name>
        <Size>16</Size>
        <Description>Window height.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>81</Id>
    <Name>WMOVE</Name>
    <LongName>Window Move</LongName>
    <Description>Repositions the window, with the given ID, and a
    (x,y) translation. The window will be repositioned the next
    time a MESSAGE or ASK, referencing this window, is
    issued.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>I</Name>
        <Size>8</Size>
        <Description>WINDOW ID to resize.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>X</Name>
        <Size>16</Size>
        <Description>X-translation of the window.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>Y</Name>
        <Size>16</Size>
        <Description>Y-translation of the window.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>82</Id>
    <Name>WMODE</Name>
    <LongName>Window Mode</LongName>
    <Description>Changes properties associated with the WINDOW
    whose ID is specified. The mode byte sets the style of the
    window, as detailed below. If the final byte is set to 1, the
    window cannot be closed by the player pushing [OK]. The mode of
    the window should be changed before it is displayed with
    MESSAGE or ASK, or the changes will not be visible unless the
    window is closed and reopened.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>N</Name>
        <Size>8</Size>
        <Description>The ID of the window whose mode will be
        set.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>M</Name>
        <Size>8</Size>
        <Description>Mode of the window. ID Mode 0 Normal 1 No
        Background/Border 2 Transparent Background</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>C</Name>
        <Size>8</Size>
        <Description>Window permanency.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>83</Id>
    <Name>WREST</Name>
    <LongName>Window Reset</LongName>
    <Description>Resets the given window, including the following
    parameters: Position and size, set by WMOVE, WSIZW, WROW or
    even the initial values set by WINDOW; Background type, set by
    WMODE; Numerical displays, set by WSPCL; Message parameters,
    set by MPARA and MPRA2. The reset window has a position of
    approximately (5,5), with a width and height of approximately
    (0x130, 0x45).</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>N</Name>
        <Size>8</Size>
        <Description>The ID of the window to reset.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>84</Id>
    <Name>WCLSE</Name>
    <LongName>Window Close</LongName>
    <Description>Closes the given window.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>N</Name>
        <Size>8</Size>
        <Description>The ID of the window to close.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>85</Id>
    <Name>WROW</Name>
    <LongName>Window Rows</LongName>
    <Description>Sets the height of the window with ID N, by
    adjusting it to fit a specified number of rows of text, as
    given by R. If the dialog does not fit after adjusting the
    height of the window, the player will be able to scroll the
    dialog in the window by pressing [OK] to see the proceeding
    lines of text. When all text has scrolled, the window will
    close as normal.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>N</Name>
        <Size>8</Size>
        <Description>The ID of the window whose height will be
        set.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>R</Name>
        <Size>8</Size>
        <Description>Number of rows of text that should fit in this
        window.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>86</Id>
    <Name>GWCOL</Name>
    <LongName>Get Window Colour</LongName>
    <Description>Gets the colour used in the gradient for windows
    in which text is displayed, into the banks and address
    specified.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>C Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>R Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B3</Name>
        <Size>4</Size>
        <Description>G Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B4</Name>
        <Size>4</Size>
        <Description>B Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>C</Name>
        <Size>8</Size>
        <Description>Corner to check, or address to retrieve value
        if B1 is non-zero. 0 Top Left 1 Bottom Left 2 Top Right 3
        Bottom Right</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>R</Name>
        <Size>8</Size>
        <Description>Address to store red component in bank
        B2.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>G</Name>
        <Size>8</Size>
        <Description>Address to store green component in bank
        B3.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>Address to store blue component in bank
        B4.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>87</Id>
    <Name>SWCOL</Name>
    <LongName>Set Window Colour</LongName>
    <Description>Sets the colour for a particular corner of the
    gradient used in windows for displaying text.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>C Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>R Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B3</Name>
        <Size>4</Size>
        <Description>G Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B4</Name>
        <Size>4</Size>
        <Description>B Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>C</Name>
        <Size>8</Size>
        <Description>Corner to check, or address to retrieve value
        if B1 is non-zero. 0 Top Left 1 Bottom Left 2 Top Right 3
        Bottom Right</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>R</Name>
        <Size>8</Size>
        <Description>Address to store red component in bank
        B2.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>G</Name>
        <Size>8</Size>
        <Description>Address to store green component in bank
        B3.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>Address to store blue component in bank
        B4.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>88</Id>
    <Name>STITM</Name>
    <LongName>Set Item</LongName>
    <Description>Adds a new item to the inventory. Either the item
    is added explicitly with values, in which case B1 and B2 are
    zero, or the item type and quantity are retrieved from memory.
    In this case, bank B1 and address T retrieve the item type,
    whilst bank B2 and address A retrieve the quantity to add.
    Example The following example adds 10 (0xA) Elixirs (ID 0x5)
    using temporary bank 5 and address 1C for item type, and a
    value for item quantity. SETBYTE(50,1C,5)
    STITM(50,1C,0,A)</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>T Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>A Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>T</Name>
        <Size>16</Size>
        <Description>Type of item to add, or source address to
        retrieve item type from.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Amount of item to add, or source address to
        retrieve item quantity from.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>89</Id>
    <Name>DLITM</Name>
    <LongName>Delete Item</LongName>
    <Description>Removes a quantity of an item from the inventory.
    Either the item is removed explicitly with values, in which
    case B1 and B2 are zero, or the item type and quantity are
    retrieved from memory. In this case, bank B1 and address T
    retrieve the item type, whilst bank B2 and address A retrieve
    the quantity to remove.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>T Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>A Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>T</Name>
        <Size>16</Size>
        <Description>Type of item to delete, or source address to
        retrieve item type from.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Amount of item to remove, or source address to
        retrieve item quantity from.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>90</Id>
    <Name>CKITM</Name>
    <LongName>Check Item</LongName>
    <Description>Copies the amount of item I the player has in
    their inventory, to the bank and address
    specified.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>Bank to store result.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>I</Name>
        <Size>16</Size>
        <Description>Item ID to check.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Address to store result.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>91</Id>
    <Name>SMTRA</Name>
    <LongName>Set Materia</LongName>
    <Description>Adds a new piece of materia to the materia
    inventory. This is either done by explicitly providing the
    materia type and AP value, in which case the first two bytes
    are zero, or by retrieving these values from memory. Both
    setting the values explicitly and retrieving from memory can be
    used together in one call by setting the correct bytes to zero;
    to see an example, please check below. If B1 is non-zero, then
    T specifies the address to be used with B1 to find the value
    for materia type. If B2, B3 or B4 are non-zero, these three
    bytes specify the addresses to retrieve the values for this
    unit. B2 and the first AP byte specifies the lowest-unit (16^1)
    hex value to retrieve, corresponding to 0-16 gil; B3 and the
    second AP byte specifies the middle-unit (16^2) hex value to
    retrieve; B4 and the third AP byte the highest-unit (16^3) hex
    value. [edit] Example The following example adds a piece of
    Slash All materia (ID: 0xE) using the following parameters:
    Materia ID retrieved from memory bank 6, address 1D; 16^1 set
    explicitly with a constant value; 16^2 set explicitly with a
    constant value; 16^3 retrieved from memory bank 6, address 1B.
    SETWORD(60,1B,1,0) SETWORD(60,1D,E,0) SMTRA(60,06,1D,3,2,1B)
    This equates to: (3*16^1) + (2*16^2) + (1*16^3) == 0x010203 ==
    66051 AP.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>T Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>AP1 Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B3</Name>
        <Size>4</Size>
        <Description>AP2 Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B4</Name>
        <Size>4</Size>
        <Description>AP3 Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>T</Name>
        <Size>8</Size>
        <Description>Type of materia to add, or source address
        1.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>AP1</Name>
        <Size>8</Size>
        <Description>Lowest unit (16^1) of AP amount the newly
        added materia will have, or source address 2</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>AP2</Name>
        <Size>8</Size>
        <Description>Middle unit (16^2) of AP amount the newly
        added materia will have, or source address 3</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>AP3</Name>
        <Size>8</Size>
        <Description>Highest unit (16^3) of AP amount the newly
        added materia will have, or source address 3</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>92</Id>
    <Name>DMTRA</Name>
    <LongName>Delete Materia</LongName>
    <Description>This opcode does not appear to function correctly
    in the PC version of the game. In addition, it is only used
    once, in the Debug Rooms.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>T Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>AP1 Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B3</Name>
        <Size>4</Size>
        <Description>AP2 Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B4</Name>
        <Size>4</Size>
        <Description>AP3 Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>T</Name>
        <Size>8</Size>
        <Description>Type of materia to add, or source address
        1.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>AP1</Name>
        <Size>8</Size>
        <Description>Lowest unit (16^1) of AP amount the newly
        added materia will have, or source address 2</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>AP2</Name>
        <Size>8</Size>
        <Description>Middle unit (16^2) of AP amount the newly
        added materia will have, or source address 3</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>AP3</Name>
        <Size>8</Size>
        <Description>Highest unit (16^3) of AP amount the newly
        added materia will have, or source address 3</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Amount to delete.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>93</Id>
    <Name>CMTRA</Name>
    <LongName>Check Materia</LongName>
    <Description>Places the amount of materia with specified type
    and AP into the bank and address specified. [edit] Important
    Note This opcode is not implemented in the PC version of the
    game, nor used in the PlayStation version.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>T Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>AP1 Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B3</Name>
        <Size>4</Size>
        <Description>AP2 Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B4</Name>
        <Size>4</Size>
        <Description>AP3 Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B5</Name>
        <Size>8</Size>
        <Description>A Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>T</Name>
        <Size>8</Size>
        <Description>Type of materia to add, or source address
        1.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>AP1</Name>
        <Size>8</Size>
        <Description>Lowest unit (16^1) of AP amount the newly
        added materia will have, or source address 2</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>AP2</Name>
        <Size>8</Size>
        <Description>Middle unit (16^2) of AP amount the newly
        added materia will have, or source address 3</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>AP3</Name>
        <Size>8</Size>
        <Description>Highest unit (16^3) of AP amount the newly
        added materia will have, or source address 3</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>U</Name>
        <Size>8</Size>
        <Description>Unknown</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Amount to delete.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>94</Id>
    <Name>SHAKE</Name>
    <LongName></LongName>
    <Description></Description>
  </Opcode>
  <Opcode>
    <Id>95</Id>
    <Name>NOP</Name>
    <LongName>No Op</LongName>
    <Description>Performs no operation.</Description>
  </Opcode>
  <Opcode>
    <Id>96</Id>
    <Name>MAPJUMP</Name>
    <LongName>Change Field</LongName>
    <Description>Switches fields to the one indicated by I, and
    places the character at the coordinates and direction
    specified. This is an alternative to using a gateway, and can
    complement their usage as it allows for more than 12 gateways
    by simulating their behaviour through a LINE which, when
    crossed, executes a MAPJUMP.</Description>
    <Operands>
      <Operand xsi:type="UShort">
        <Name>I</Name>
        <Size>16</Size>
        <Description>Field ID of the map to jump to.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>X</Name>
        <Size>16</Size>
        <Description>X-coordinate of the player on the next
        field.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>Y</Name>
        <Size>16</Size>
        <Description>Y-coordinate of the player on the next
        field.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>Z</Name>
        <Size>16</Size>
        <Description>Z-coordinate of the player on the next
        field.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>D</Name>
        <Size>8</Size>
        <Description>Direction the character will be facing on the
        next field, in the standard game format.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>97</Id>
    <Name>SCRLO</Name>
    <LongName></LongName>
    <Description></Description>
  </Opcode>
  <Opcode>
    <Id>98</Id>
    <Name>SCRLC</Name>
    <LongName></LongName>
    <Description></Description>
  </Opcode>
  <Opcode>
    <Id>99</Id>
    <Name>SCRLA</Name>
    <LongName>Scroll To Entity</LongName>
    <Description>Scrolls the current view so that the field object
    associated with entity E is in the center of the view. The
    scroll occurs at speed S, and with a particular style, T. If an
    entity is given that does not have a field object, the view
    centers on the walkmesh origin. If the object is moving as the
    scroll occurs, the scroll will follow the object until it is
    centered. Also of note is that the scroll will not leave the
    boundaries of the background (as defined by the range values in
    section 8), unlike the standard "scroll to coordinate"
    opcodes.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>Bank for the scroll speed, or zero if it is
        specified as a literal value.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>S</Name>
        <Size>16</Size>
        <Description>Speed of the scroll, in frames, or the address
        to find the speed if B is non-zero.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>E</Name>
        <Size>8</Size>
        <Description>Entity ID to scroll to.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>T</Name>
        <Size>8</Size>
        <Description>Type of scroll ID Scroll Type 0 No Scroll 1
        Instantaneous 2 Linear 3 Smooth</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>100</Id>
    <Name>SCR2D</Name>
    <LongName>Scroll 2D</LongName>
    <Description>Instantaneously scrolls the current view to the
    coordinates found in the arguments (or the values found at the
    addresses if memory banks and address are specified). The move
    to the new coordinates is instant; variants exist for linear
    and smooth scrolling.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>X Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>Y Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>X</Name>
        <Size>16</Size>
        <Description>X-coordinate to scroll to, or address to
        find&#160;X&#160;if&#160;B1&#160;is non-zero.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>Y</Name>
        <Size>16</Size>
        <Description>Y-coordinate to scroll to, or address to
        find&#160;Y&#160;if&#160;B2&#160;is non-zero.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>101</Id>
    <Name>SCRCC</Name>
    <LongName>Scroll To Playable Character</LongName>
    <Description>Instantaneously scrolls the current view so that
    it is centered on the current playable character.</Description>
  </Opcode>
  <Opcode>
    <Id>102</Id>
    <Name>SCR2DC</Name>
    <LongName>Scroll to Coordinates (Smooth)</LongName>
    <Description>Similar to SCR2D, except the scroll is not
    instantaneous and is performed smoothly, with a slower start
    and ending, with speed peaking in the center of the scroll. The
    overall speed can be set with S.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>X Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>Y Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>0</Name>
        <Size>4</Size>
        <Description>Zero</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B4</Name>
        <Size>4</Size>
        <Description>S Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>X</Name>
        <Size>16</Size>
        <Description>X-coordinate to scroll to.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>Y</Name>
        <Size>16</Size>
        <Description>Y-coordinate to scroll to.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>S</Name>
        <Size>16</Size>
        <Description>Speed to scroll; higher values scroll more
        slowly.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>103</Id>
    <Name>SCRLW</Name>
    <LongName>Wait for scroll</LongName>
    <Description>Halts execution of the current script for a
    preceding scroll to have reached its destination coordinates
    before continuing.</Description>
  </Opcode>
  <Opcode>
    <Id>104</Id>
    <Name>SCR2DL</Name>
    <LongName>Scroll to Coordinates (Linear)</LongName>
    <Description>Similar to SCR2D, except the scroll to the
    coordinates is linear; that is, the speed is constant
    throughout the duration of the screen scroll.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>X Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>Y Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>0</Name>
        <Size>4</Size>
        <Description>Zero</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B4</Name>
        <Size>4</Size>
        <Description>S Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>X</Name>
        <Size>16</Size>
        <Description>X-coordinate to scroll to.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>Y</Name>
        <Size>16</Size>
        <Description>Y-coordinate to scroll to.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>S</Name>
        <Size>16</Size>
        <Description>Speed to scroll; higher values scroll more
        slowly.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>105</Id>
    <Name>MPDSP</Name>
    <LongName></LongName>
    <Description></Description>
  </Opcode>
  <Opcode>
    <Id>106</Id>
    <Name>VWOFT</Name>
    <LongName></LongName>
    <Description></Description>
  </Opcode>
  <Opcode>
    <Id>107</Id>
    <Name>FADE</Name>
    <LongName>Fade</LongName>
    <Description>Fades the screen to the colour specified, either
    as literal values or values from memory, using the type of fade
    specified by T. The speed of the fade is specified by S, but
    can also be adjusted based on the type of fade. If the fade
    type is a fade out (to the colour given), the adjustment ranges
    from a value of zero (fades at speed S), and a value of 0xFF
    (instant fade). If the fade type is a fade back (from fade
    colour back to the normal screen), these are reversed, and zero
    indicates an instant return, whilst 0xFF fades back at speed
    S.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>R Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>G Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>0</Name>
        <Size>4</Size>
        <Description>Zero</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B4</Name>
        <Size>4</Size>
        <Description>B Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>R</Name>
        <Size>8</Size>
        <Description>Red component value, or address of red value
        if B1 is non-zero.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>G</Name>
        <Size>8</Size>
        <Description>Green component value, or address of red value
        if B2 is non-zero.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>Blue component value, or address of blue value
        if B4 is non-zero.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>S</Name>
        <Size>8</Size>
        <Description>Speed of fade. Larger numbers indicate faster
        fades.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>T</Name>
        <Size>8</Size>
        <Description>Type of fade; ID Fade Type 3 Black to Screen
        (Instant) 4 Screen to Black (Instant) 5 Colour Fade to
        Screen 6 Screen to Colour Fade</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Adjusts the speed of the fade, based on fade
        in/out.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>108</Id>
    <Name>FADEW</Name>
    <LongName>Wait for fade</LongName>
    <Description>Halts execution of the current script for a
    preceding FADE command, issued by any entity, to fully complete
    before continuing execution. If no FADE has been issued by any
    entity, or previous FADE calls have already completed, the
    FADEW call is ignored.</Description>
  </Opcode>
  <Opcode>
    <Id>109</Id>
    <Name>IDLCK</Name>
    <LongName>Triangle Boundary</LongName>
    <Description>Dynamically turns on or off the boundary status
    for the set of edges marked by the triangle ID I. If the
    boundary status is switched to on, the player will not be able
    to cross the edges of the triangle given. If switched to off,
    the player may walk freely through the same
    edges.</Description>
    <Operands>
      <Operand xsi:type="UShort">
        <Name>I</Name>
        <Size>16</Size>
        <Description>Triangle ID</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>S</Name>
        <Size>8</Size>
        <Description>Switch boundary off/on (0/1,
        respectively)</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>110</Id>
    <Name>LSTMP</Name>
    <LongName>Last Map</LongName>
    <Description>Retrieves the field ID number of the field that
    was played directly before the current one, into the bank B and
    address A specified. The previous area does not include the
    specific world map locations that are given a field ID (0x1 to
    0x40), so traversing via a gateway to the world map, then back
    to the field, will not cause the world map ID to be retrieved;
    rather, that same field ID will be loaded.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>A Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Address to store value</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>111</Id>
    <Name>SCRLP</Name>
    <LongName>Scroll To Party Member</LongName>
    <Description>Similar to SCRLA, except the scroll moves towards
    the given party member, rather than a particular
    entity.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>Bank for the scroll speed, or zero if it is
        specified as a literal value.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>S</Name>
        <Size>16</Size>
        <Description>Speed of the scroll, in frames, or the address
        to find the speed if B is non-zero.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>P</Name>
        <Size>8</Size>
        <Description>Party ID to scroll to, between 0 and
        2.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>T</Name>
        <Size>8</Size>
        <Description>Type of scroll ID Scroll Type 0 No Scroll 1
        Instantaneous 2 Linear 3 Smooth</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>112</Id>
    <Name>BATTLE</Name>
    <LongName>Start Battle</LongName>
    <Description>This launches the battle module with whatever
    battle number is used in the argument, or the value retrieved
    from memory location N if B is non-zero. Battle 1, 2, and 999
    (0x03E7) are debug battles.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>Bank (16-bit) to retrieve the address of the
        battle ID, or zero if it is given as a literal
        value.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>N</Name>
        <Size>16</Size>
        <Description>Battle ID, or address to find ID if B is
        non-zero.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>113</Id>
    <Name>BTLON</Name>
    <LongName>Battle Switch</LongName>
    <Description>Turns random encounters on or off for this field.
    Note that if a field does not have any Encounter Data set in
    its field file, battles will not occur regardless of the
    argument passed with this opcode.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>S</Name>
        <Size>8</Size>
        <Description>Switch battles on/off (0/1,
        respectively).</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>114</Id>
    <Name>BTLMD</Name>
    <LongName>Battle Mode</LongName>
    <Description>Sets properties for the battle module. The
    argument is a bit field with bits that can be ORd together to
    set multiple battle properties.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>MSB</Name>
        <Size>8</Size>
        <Description>First Byte (MSB) Bit Description (Bit set to
        1) 0x80 (10000000) Do not display the AP/EXP/Gil/items
        received screens. 0x40 (01000000) Activates the battle
        arena. The next chosen BATTLE instead takes place in the
        arena, but keeping the same enemy formation. The "keep
        going/no way" interface is enabled. 0x20 (00100000) Do not
        play the battle victory music. 0x08 (00001000) The party
        cannot escape the battle. 0x04 (00000100) Pre-emptive
        attack. 0x02 (00000010) The battle is timed; the player
        must complete the battle before the timer reaches zero, or
        the battle exits, with no AP/EXP/Gil/items received screens
        displayed.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>8</Size>
        <Description>Second Byte Bit Description (Bit set to 1)
        0x01 (00000001) Disable game over. After a party defeat,
        the game returns to the previous field.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>115</Id>
    <Name>PGTDR</Name>
    <LongName>Get Party Member Direction</LongName>
    <Description>Fetches the orientation of the party member
    specified by P on the field, into the bank and address
    specified by B and D.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>Bank to store direction</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>P</Name>
        <Size>8</Size>
        <Description>Party member ID, from 0 to 2.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>D</Name>
        <Size>8</Size>
        <Description>Address to store direction.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>116</Id>
    <Name>GETPC</Name>
    <LongName>Get Party Character</LongName>
    <Description>Gets the standard Character ID for the party
    member, referenced by C. This value is between 0 and 2; 0 for
    the party member at the top of the list, 1 for the member in
    the middle, and 2 for the member in the bottom slot, as found
    in the main menu. The character ID is then placed at the
    specified bank and address.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>Bank to store the value</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>C</Name>
        <Size>8</Size>
        <Description>Character offset in the party whose value
        should be retrieved.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Address to store the value</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>117</Id>
    <Name>PXYZI</Name>
    <LongName>Party Member Get Position</LongName>
    <Description>Retrieves the coordinates of the party member
    specified by P. If an invalid party member ID is specified,
    zeros are stored in the four addresses.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>X Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>Y Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B3</Name>
        <Size>4</Size>
        <Description>Z Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B4</Name>
        <Size>4</Size>
        <Description>I Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>P</Name>
        <Size>8</Size>
        <Description>Party member to retrieve data from; range is 0
        to 2.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>X</Name>
        <Size>8</Size>
        <Description>Address to store the X-coordinate of the party
        member</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>Y</Name>
        <Size>8</Size>
        <Description>Address to store the Y-coordinate of the party
        member.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>Z</Name>
        <Size>8</Size>
        <Description>Address to store the Z-coordinate of the party
        member.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>I</Name>
        <Size>8</Size>
        <Description>Address to store the ID of the walkmesh
        triangle the party member is standing on.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>118</Id>
    <Name>PLUS!</Name>
    <LongName>Saturated Addition (8-bit)</LongName>
    <Description>Adds two numbers together and stores the result
    back into D. The result of the addition is capped at 255. If
    the Source Bank is 0 then the O is added to the destination
    value. If the Source Bank is an 8 bit bank, then the O is the
    address in that bank where the operand is.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>D bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>O bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>D</Name>
        <Size>8</Size>
        <Description>Destination address</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>O</Name>
        <Size>8</Size>
        <Description>Operand address</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>119</Id>
    <Name>PLUS2!</Name>
    <LongName>Saturated Addition (16-bit)</LongName>
    <Description>Adds two numbers together and stores the result
    back into D The result of the addition is capped at 32767. The
    result is not capped at the negative end, however (-32768), so
    adding two large negative numbers together will still produce
    wrap-around. If the Source Bank is 0 then the O is added to the
    destination value. If the Source Bank is an 16 bit bank, then
    the O is the address in that bank where the operand
    is.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>D bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>O bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>D</Name>
        <Size>8</Size>
        <Description>Destination address</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>O</Name>
        <Size>16</Size>
        <Description>Operand address</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>120</Id>
    <Name>MINUS!</Name>
    <LongName>Saturated Subtraction (8-bit)</LongName>
    <Description>Subtracts O from D and stores the result back into
    D. The result of the subtraction is capped at 0. If the Source
    Bank is 0 then the O is subtracted from the destination value.
    If the Source Bank is an 8 bit bank, then the O is the address
    in that bank where the operand is.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>D bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>O bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>D</Name>
        <Size>8</Size>
        <Description>Destination address</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>O</Name>
        <Size>8</Size>
        <Description>Operand address</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>121</Id>
    <Name>MINUS2!</Name>
    <LongName>Saturated Subtraction (16-bit)</LongName>
    <Description>Subtracts O from D and stores the result back into
    D. The result of the subtraction is capped at -32768. The
    result is not capped at the positive end (32767), so
    subtracting a large negative number from a large positive
    number will still produce wrap-around. If the Source Bank is 0
    then the O is subtracted from the destination value. If the
    Source Bank is an 16 bit bank, then the O is the address in
    that bank where the operand is.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>D bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>O bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>D</Name>
        <Size>8</Size>
        <Description>Destination address</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>O</Name>
        <Size>16</Size>
        <Description>Operand address</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>122</Id>
    <Name>INC!</Name>
    <LongName>Saturated Increment (8-bit)</LongName>
    <Description>Increments the value in D by 1. The result is
    capped at 255.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>0</Name>
        <Size>4</Size>
        <Description>Zero</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>D bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>D</Name>
        <Size>8</Size>
        <Description>The destination address in the bank where the
        variable is incremented.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>123</Id>
    <Name>INC2!</Name>
    <LongName>Saturated Increment (16-bit)</LongName>
    <Description>Increments the value in D by 1. The result is
    capped at 32767.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>0</Name>
        <Size>4</Size>
        <Description>Zero</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>D bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>D</Name>
        <Size>8</Size>
        <Description>The destination address in the bank where the
        variable is incremented.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>124</Id>
    <Name>DEC!</Name>
    <LongName>Saturated Decrement (8-bit)</LongName>
    <Description>Decreases the value in D by 1. The result is
    capped at 0.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>0</Name>
        <Size>4</Size>
        <Description>Zero</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>D bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>D</Name>
        <Size>8</Size>
        <Description>The destination address in the bank where the
        variable is decremented.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>125</Id>
    <Name>DEC2!</Name>
    <LongName>Saturated Decrement (16-bit)</LongName>
    <Description>Decreases the value in D by 1. The result is
    capped at -32768.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>0</Name>
        <Size>4</Size>
        <Description>Zero</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>D bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>D</Name>
        <Size>8</Size>
        <Description>The destination address in the bank where the
        variable is decremented.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>126</Id>
    <Name>TLKON</Name>
    <LongName>Talk Switch</LongName>
    <Description>Turns on or off, for an entity, the ability for
    the playable character to interact with the entity by pressing
    the [X] button. More precisely, this enables or disables the On
    Press script (script 2); if set to off, script 2 will not
    execute when the button is pressed and the player is facing the
    entity's object. If set to on, the script will execute, as
    normal.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>Switch on/off (0/1,
        respectively).</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>127</Id>
    <Name>RDMSD</Name>
    <LongName>Seed Random Generator</LongName>
    <Description>Seeds the random number generator used by RANDOM.
    The lower four bits of the arguments are used as the seed value
    by altering the offset used to take a value from the table of
    pseudo-random numbers.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>S Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>S</Name>
        <Size>8</Size>
        <Description>Seed for the random generator, or address for
        the seed if B is non-zero.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>128</Id>
    <Name>SETBYTE</Name>
    <LongName>Byte Set</LongName>
    <Description>Writes the byte value from the source address, or
    the value argument itself, into the destination 8-bit bank. If
    the source bank S is zero, the value given by V is written
    directly into the destination address; otherwise, the value is
    retrieved from the source bank/address S/V, and then written to
    the destination bank/address D/A. If the destination is a
    16-bit bank, the high byte of the destination will remain
    unchanged.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>A Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>V Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Destination address</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>V</Name>
        <Size>8</Size>
        <Description>&#160;Value to be written/Source
        address.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>129</Id>
    <Name>SETWORD</Name>
    <LongName>Word Set</LongName>
    <Description>Writes the word value from the source address, or
    the value argument itself, into the destination 16-bit bank. If
    the source bank S is zero, the value given by V is written
    directly into the destination bank/address; otherwise, the
    value is retrieved from the source bank/address S/V, and then
    written to the destination bank/address D/A. If the destination
    is a 8-bit bank, only the low byte of the source will be
    written into it.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>A Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>V Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Destination address</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>V</Name>
        <Size>16</Size>
        <Description>&#160;Value to be written/Source
        address.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>130</Id>
    <Name>BITON</Name>
    <LongName>Set Bit</LongName>
    <Description>Sets the nth bit in the D location, where n is a
    number between 0-7 supplied in B. A value of zero in B will set
    the least significant bit. If the Source Bank is 0 then the bit
    to be set is taken from B. If the Source Bank is an 8 bit bank,
    then the &#8220;Bit&#8221; is the address in that bank where
    the operand is.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>A Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>B Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Destination address</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>The number of the bit to turn
        on.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>131</Id>
    <Name>BITOFF</Name>
    <LongName>Reset Bit</LongName>
    <Description>Sets the nth bit in the D location, where n is a
    number between 0-7 supplied in B. A value of zero in B will
    reset the least significant bit. If the Source Bank is 0 then
    the bit to be set is taken from B. If the Source Bank is an 8
    bit bank, then the &#8220;Bit&#8221; is the address in that
    bank where the operand is.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>A Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>B Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Destination address</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>The number of the bit to turn
        off.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>132</Id>
    <Name>BITXOR</Name>
    <LongName>Toggle Bit</LongName>
    <Description>Toggles the nth bit in the D location, where n is
    a number between 0-7 supplied in B. A value of zero in B will
    toggle the least significant bit. If the Source Bank is 0 then
    the bit to be changed is taken from B. If the Source Bank is an
    8 bit bank, then the &#8220;Bit&#8221; is the address in that
    bank where the operand is.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>A Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>B Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Destination address</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>The number of the bit to turn
        toggle.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>133</Id>
    <Name>PLUS</Name>
    <LongName>Addition (8-bit)</LongName>
    <Description>Adds two numbers together and stores the result
    back into D. The result of the addition wraps around into the
    range of 0-255. If the Source Bank is 0 then the O is added to
    the destination value. If the Source Bank is an 8 bit bank,
    then the O is the address in that bank where the operand
    is.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>D bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>O bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>D</Name>
        <Size>8</Size>
        <Description>Destination address</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>O</Name>
        <Size>8</Size>
        <Description>Operand address</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>134</Id>
    <Name>PLUS2</Name>
    <LongName>Addition (16-bit)</LongName>
    <Description>Adds two numbers together and stores the result
    back into D. The result of the addition wraps around into the
    16-bit range. If the Source Bank is 0 then the O is added to
    the destination value. If the Source Bank is an 16 bit bank,
    then the O is the address in that bank where the operand
    is.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>D bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>O bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>D</Name>
        <Size>8</Size>
        <Description>Destination address</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>O</Name>
        <Size>16</Size>
        <Description>Operand address</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>135</Id>
    <Name>MINUS</Name>
    <LongName>Subtraction (8-bit)</LongName>
    <Description>Subtracts two numbers and stores the result back
    into D. The result of the subtraction wraps around into the
    range of 0-255. If the Source Bank is 0 then the O is
    subtracted from the destination value. If the Source Bank is an
    8 bit bank, then the O is the address in that bank where the
    operand is.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>D bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>O bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>D</Name>
        <Size>8</Size>
        <Description>Destination address</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>O</Name>
        <Size>8</Size>
        <Description>Operand address</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>136</Id>
    <Name>MINUS2</Name>
    <LongName>Subtraction (16-bit)</LongName>
    <Description>Subtracts two numbers and stores the result back
    into D. The result of the subtraction wraps around into the
    16-bit range. If the Source Bank is 0 then the O is subtracted
    from the destination value. If the Source Bank is an 16 bit
    bank, then the O is the address in that bank where the operand
    is.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>D bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>O bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>D</Name>
        <Size>8</Size>
        <Description>Destination address</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>O</Name>
        <Size>16</Size>
        <Description>Operand address</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>137</Id>
    <Name>MUL</Name>
    <LongName>Multiplication (8-bit)</LongName>
    <Description>Multiplies two numbers together and stores the
    result back into D. The result of the Multiplication is capped
    at 255. If the Source Bank is 0 then the the value O is
    multiplied with the destination value. If the Source Bank is an
    8 bit bank, then the O is the address in that bank where the
    operand is.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>D bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>O bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>D</Name>
        <Size>8</Size>
        <Description>Destination address</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>O</Name>
        <Size>8</Size>
        <Description>Operand address</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>138</Id>
    <Name>MUL2</Name>
    <LongName>Multiplication (16-bit)</LongName>
    <Description>Multiplies two numbers together and stores the
    result back into D. The result of the Multiplication is capped
    at 32767. If the Source Bank is 0 then the the value O is
    multiplied with the destination value. If the Source Bank is an
    8 bit bank, then the O is the address in that bank where the
    operand is.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>D bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>O bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>D</Name>
        <Size>8</Size>
        <Description>Destination address</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>O</Name>
        <Size>16</Size>
        <Description>Operand address</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>139</Id>
    <Name>DIV</Name>
    <LongName>Division (8-bit)</LongName>
    <Description>Divides D by O and stores the result back into D.
    The result of the division is rounded towards zero to the
    nearest integer. If the Source Bank is 0 then the O is the
    denominator. If the Source Bank is an 8 bit bank, then the O is
    the address in that bank where the denominator
    is.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>D bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>O bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>D</Name>
        <Size>8</Size>
        <Description>Destination address</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>O</Name>
        <Size>8</Size>
        <Description>Operand address</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>140</Id>
    <Name>DIV2</Name>
    <LongName>Division (16-bit)</LongName>
    <Description>Divides D by O and stores the result back into D.
    The result of the division is rounded towards negative infinity
    to the nearest integer. If the Source Bank is 0 then the O is
    the denominator. If the Source Bank is an 16 bit bank, then the
    O is the address in that bank where the denominator
    is.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>D bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>O bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>D</Name>
        <Size>8</Size>
        <Description>Destination address</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>O</Name>
        <Size>16</Size>
        <Description>Operand address</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>141</Id>
    <Name>MOD</Name>
    <LongName>Modulus (8-bit)</LongName>
    <Description>Divides D by O and stores the remainder back into
    D. If the Source Bank is 0 then the O is the denominator. If
    the Source Bank is an 8 bit bank, then the O is the address in
    that bank where the denominator is.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>D bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>O bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>D</Name>
        <Size>8</Size>
        <Description>Destination address</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>O</Name>
        <Size>8</Size>
        <Description>Operand address</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>142</Id>
    <Name>MOD2</Name>
    <LongName>Modulus (16-bit)</LongName>
    <Description>Divides D by O and stores the remainder back into
    D. If the Source Bank is 0 then the O is the denominator. If
    the Source Bank is an 16 bit bank, then the O is the address in
    that bank where the denominator is.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>D bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>O bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>D</Name>
        <Size>8</Size>
        <Description>Destination address</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>O</Name>
        <Size>16</Size>
        <Description>Operand address</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>143</Id>
    <Name>AND</Name>
    <LongName>Bitwise AND (8-bit)</LongName>
    <Description>Performs a bitwise AND operation between D and O
    and stores the result back into D. If the Source Bank is 0 then
    the O is the operand to AND with. If the Source Bank is an 8
    bit bank, then the O is the address in that bank where the
    operand is.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>D bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>O bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>D</Name>
        <Size>8</Size>
        <Description>Destination address</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>O</Name>
        <Size>8</Size>
        <Description>Operand address</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>144</Id>
    <Name>AND2</Name>
    <LongName>Bitwise AND (16-bit)</LongName>
    <Description>Performs a bitwise AND operation between D and O
    and stores the result back into Dest. If the Source Bank is 0
    then the O is the operand to AND with. If the Source Bank is a
    16-bit bank, then the O is the address in that bank where the
    operand is.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>D bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>O bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>D</Name>
        <Size>8</Size>
        <Description>Destination address</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>O</Name>
        <Size>16</Size>
        <Description>Operand address</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>145</Id>
    <Name>OR</Name>
    <LongName>Bitwise OR (8-bit)</LongName>
    <Description>Performs a bitwise OR operation between D and O
    and stores the result back into D. If the Source Bank is 0 then
    the O is the operand to OR with. If the Source Bank is an 8 bit
    bank, then the O is the address in that bank where the operand
    is.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>D bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>O bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>D</Name>
        <Size>8</Size>
        <Description>Destination address</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>O</Name>
        <Size>8</Size>
        <Description>Operand address</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>146</Id>
    <Name>OR2</Name>
    <LongName>Bitwise OR (16-bit)</LongName>
    <Description>Performs a bitwise OR operation between D and O
    and stores the result back into Dest. If the Source Bank is 0
    then O is the operand to OR with. If the Source Bank is a
    16-bit bank, then the O is the address in that bank where the
    operand is.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>D bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>O bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>D</Name>
        <Size>8</Size>
        <Description>Destination address</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>O</Name>
        <Size>16</Size>
        <Description>Operand address</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>147</Id>
    <Name>XOR</Name>
    <LongName>Bitwise XOR (8-bit)</LongName>
    <Description>Performs a bitwise XOR operation between D and O
    and stores the result back into D. If the Source Bank is 0 then
    the O is the operand to XOR with. If the Source Bank is an 8
    bit bank, then the O is the address in that bank where the
    operand is.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>D bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>O bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>D</Name>
        <Size>8</Size>
        <Description>Destination address</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>O</Name>
        <Size>8</Size>
        <Description>Operand address</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>148</Id>
    <Name>XOR2</Name>
    <LongName>Bitwise XOR (16-bit)</LongName>
    <Description>Performs a bitwise XOR operation between D and O
    and stores the result back into Dest. If the Source Bank is 0
    then O is the operand to OR with. If the Source Bank is a
    16-bit bank, then the O is the address in that bank where the
    operand is.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>D bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>O bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>D</Name>
        <Size>8</Size>
        <Description>Destination address</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>O</Name>
        <Size>16</Size>
        <Description>Operand address</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>149</Id>
    <Name>INC</Name>
    <LongName>Increment (8-bit)</LongName>
    <Description>Increments the 8-bit value found at bank B,
    address A. If the value is 0xFF, it will roll over to 0x00. If
    you specify a 16-bit bank, only the lower byte will be
    incremented, and if the lower byte is 0xFF, the higher byte
    will be unaffected whilst the lower byte will return to
    0x00.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>A Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Address</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>150</Id>
    <Name>INC2</Name>
    <LongName>Increment (16-bit)</LongName>
    <Description>Increments the 16-bit value found at bank B,
    address A. If the value is 0xFFFF, it will roll over to
    0x0000.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>A Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Address</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>151</Id>
    <Name>DEC</Name>
    <LongName>Decrement (8-bit)</LongName>
    <Description>Decrements the 8-bit value found at bank B,
    address A. If the value is 0x00, it will roll over to 0xFF. If
    you specify a 16-bit bank, only the lower byte will be
    decremented, and if the lower byte is 0x00, the higher byte
    will be unaffected whilst the lower byte will return to
    0xFF.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>A Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Address</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>152</Id>
    <Name>DEC2</Name>
    <LongName>Decrement (16-bit)</LongName>
    <Description>Decrements the 16-bit value found at bank B,
    address A. If the value is 0x0000, it will roll over to
    0xFFFF.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>A Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Address</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>153</Id>
    <Name>RANDOM</Name>
    <LongName>Random</LongName>
    <Description>Places a random 8-bit value into the destination
    bank and address specified. If you specify a 16-bit bank, only
    the lower byte is randomised.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>A Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Address</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>154</Id>
    <Name>LBYTE</Name>
    <LongName>Low Byte</LongName>
    <Description>Retrieves the low byte of a two-byte word from the
    source bank and address, and places the byte value into the
    destination bank and address. If the source is an 8-bit bank,
    this will simply copy the value from source to destination; if
    the destination is a 16-bit bank, the high byte of the
    destination will remain unchanged.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>D bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>S bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>D</Name>
        <Size>8</Size>
        <Description>Destination address</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>S</Name>
        <Size>8</Size>
        <Description>Source address</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>155</Id>
    <Name>HBYTE</Name>
    <LongName>High Byte</LongName>
    <Description>Retrieves the high byte of a two-byte word from
    the source bank and address, and places the byte value into the
    destination bank and address. If the source bank is zero, then
    the final two arguments are actually a given two-byte word
    value, and the high byte value is retrieved from this word
    instead of from a memory address.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>D bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>S bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>D</Name>
        <Size>8</Size>
        <Description>Destination address</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>S</Name>
        <Size>16</Size>
        <Description>Source address</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>156</Id>
    <Name>2BYTE</Name>
    <LongName>Two Byte Value</LongName>
    <Description>Constructs and stores a two-byte value from two
    seperate one-byte values. The low and high bytes of the
    two-byte word may be taken from existing values from memory, or
    specified as a value (or both).</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>D bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>L bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B3</Name>
        <Size>8</Size>
        <Description>H bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>D</Name>
        <Size>8</Size>
        <Description>Destination address</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>L</Name>
        <Size>8</Size>
        <Description>Low byte, or address to retrieve value if B2
        is non-zero.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>H</Name>
        <Size>8</Size>
        <Description>High byte, or address to retrieve value if B3
        is non-zero.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>157</Id>
    <Name>SETX</Name>
    <LongName></LongName>
    <Description></Description>
  </Opcode>
  <Opcode>
    <Id>158</Id>
    <Name>GETX</Name>
    <LongName></LongName>
    <Description></Description>
  </Opcode>
  <Opcode>
    <Id>159</Id>
    <Name>SEARCHX</Name>
    <LongName>Search into var map</LongName>
    <Description>Search the value V between Ofst + Start and Ofst +
    End in the bank B1 and store the position in R if found, or -1
    of not.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>Source bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>Start bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B3</Name>
        <Size>4</Size>
        <Description>End bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B4</Name>
        <Size>4</Size>
        <Description>V bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>0</Name>
        <Size>4</Size>
        <Description>Zero</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B6</Name>
        <Size>4</Size>
        <Description>R bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>O</Name>
        <Size>8</Size>
        <Description>Offset</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>Start</Name>
        <Size>16</Size>
        <Description>Start offset.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>End</Name>
        <Size>16</Size>
        <Description>End offset.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>V</Name>
        <Size>8</Size>
        <Description>Value to search.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>R</Name>
        <Size>8</Size>
        <Description>Result adress.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>160</Id>
    <Name>PC</Name>
    <LongName>Playable Character</LongName>
    <Description>Defines the entity in which this script resides as
    a playable character. The entity then becomes associated with
    the character ID C, including the entity's visible object,
    animation set, and scripts. For example, creating a visible
    entity and inserting PC(0) into its initialisation script will
    associate this entity with character ID 0.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>C</Name>
        <Size>8</Size>
        <Description>Character ID</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>161</Id>
    <Name>CHAR</Name>
    <LongName>Character definition</LongName>
    <Description>Defines a character, or rather, a visible entity.
    This means that the entity executing this opcode can be
    associated with a field object, and thus displayed on the
    walkmesh, as defined in Section 3. Note that the character ID
    does not provide an index into the field object array as you
    might expect. Infact, the field object that this CHARacter will
    use is related solely to the position of this entity amongst
    the other visible entities in the set. For example, if you have
    the following entities and objects loaded: Ent1 (Visible, CHAR
    (00)) Ent2 (Visible, CHAR (01)) Ent3 (Visible, CHAR (02)) Ent4
    FObject1 FObject2 FObject3 Ent1 will be associated with FObject
    1, Ent2 with FObject 2, and Ent3 with FObject3. If you were to
    edit as such: Ent1 (Visible, CHAR (60)) Ent2 (Visible, CHAR
    (12)) Ent3 Ent4 (Visible, CHAR (FF)) FObject1 FObject2 FObject3
    Ent1 will be associated with FObject 1, Ent2 with FObject 2,
    and Ent4 with FObject3. As you can see, the argument provides
    no information as to which object to use. Simply put, as each
    CHAR entity is read, the next sequential field object in the
    loader is assigned to it.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>N</Name>
        <Size>8</Size>
        <Description>Character ID.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>162</Id>
    <Name>DFANM</Name>
    <LongName>Animate, Loop</LongName>
    <Description>Plays the animation given by A at the speed S. The
    animation loops (plays, completes, then rewinds and plays
    again) until another animation is played, either using any
    animation opcode, or an opcode indirectly changes the animation
    being played, such as MOVE.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Animation ID for this entity's field
        object.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>S</Name>
        <Size>8</Size>
        <Description>Speed the animation is played at. Higher
        numbers indicate slower animations.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>163</Id>
    <Name>ANIME1</Name>
    <LongName>Wait While Animate/Return</LongName>
    <Description>Plays the animation found at ID A in this entity's
    field object, at the speed marked by S. When the animation is
    completed, the field object returns to its original state. The
    current script's execution is halted whilst the animation is
    played, and continues when the animation has
    completed.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Animation ID for this entity's field
        object.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>S</Name>
        <Size>8</Size>
        <Description>Speed the animation is played at. Real model
        animation speed divide by this to calculate real play
        speed.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>164</Id>
    <Name>VISI</Name>
    <LongName>Visibility</LongName>
    <Description>Sets whether this entity's field object is
    visible.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>S</Name>
        <Size>8</Size>
        <Description>Switch on/off (1/0,
        respectively).</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>165</Id>
    <Name>XYZI</Name>
    <LongName>Place Object</LongName>
    <Description>Places the field object for this entity on the
    walkmesh at the coordinates given. This variant of object
    placement allows the Z-coordinate of the object to be
    specified, as well as the ID of the walkmesh triangle on which
    the object is being placed.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>X Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>Y Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B3</Name>
        <Size>4</Size>
        <Description>Z Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B4</Name>
        <Size>4</Size>
        <Description>I Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>X</Name>
        <Size>16</Size>
        <Description>X-coordinate of the field object, or address
        of X-coordinate if B1 is non-zero.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>Y</Name>
        <Size>16</Size>
        <Description>Y-coordinate of the field object, or address
        of Y-coordinate if B2 is non-zero.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>Z</Name>
        <Size>16</Size>
        <Description>Z-coordinate of the field object, or address
        of Z-coordinate if B3 is non-zero.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>I</Name>
        <Size>16</Size>
        <Description>ID of the walkmesh triangle, or address of
        value if B4 is non-zero.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>166</Id>
    <Name>XYI</Name>
    <LongName>Place Object (No Z)</LongName>
    <Description>Similar to XYZI, but does not specify a
    Z-coordinate. This lack of Z-coordinate may be a problem when
    placing the object on a mesh that has multiple Z-levels on the
    same X- and Y-coordinates.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>X Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>Y Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B3</Name>
        <Size>4</Size>
        <Description>I Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>0</Name>
        <Size>4</Size>
        <Description>Zero</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>X</Name>
        <Size>16</Size>
        <Description>X-coordinate of the field object, or address
        of X-coordinate if B1 is non-zero.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>Y</Name>
        <Size>16</Size>
        <Description>Y-coordinate of the field object, or address
        of Y-coordinate if B2 is non-zero.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>I</Name>
        <Size>16</Size>
        <Description>Triangle ID, or address of ID
        if&#160;B3&#160;is non-zero.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>167</Id>
    <Name>XYZ</Name>
    <LongName>Place Object (No I)</LongName>
    <Description>Similar to XYZI, but does not specify a triangle
    ID. This lack of triangle ID may cause problems if the field
    object is set to move from its set position.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>X Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>Y Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B3</Name>
        <Size>4</Size>
        <Description>Z Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>0</Name>
        <Size>4</Size>
        <Description>Zero</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>X</Name>
        <Size>16</Size>
        <Description>X-coordinate of the field object, or address
        of X-coordinate if B1 is non-zero.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>Y</Name>
        <Size>16</Size>
        <Description>Y-coordinate of the field object, or address
        of Y-coordinate if B2 is non-zero.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>Z</Name>
        <Size>16</Size>
        <Description>Z-coordinate of the field object, or address
        of Z-coordinate if B3 is non-zero.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>168</Id>
    <Name>MOVE</Name>
    <LongName>Move Object</LongName>
    <Description>Makes the field object, associated with the entity
    this opcode's script resides in, walk (or move gradually) to
    the point specified by the coordinates, at the speed previously
    specified by MSPED. The object's standard walk animation is
    used, found with animation ID 1 in the field object associated
    with this entity.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>X Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>Y Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>X</Name>
        <Size>16</Size>
        <Description>X-coordinate, or lower byte specifying an
        address for the value if B1 is non-zero.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>Y</Name>
        <Size>16</Size>
        <Description>Y-coordinate, or lower byte specifying an
        address for the value if B2 is non-zero.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>169</Id>
    <Name>CMOVE</Name>
    <LongName>Move Object (No Animation)</LongName>
    <Description>Similar to MOVE, but the field object won't play
    its animation whilst it moves. Field object will not be rotated
    according to movement (it will move without changing
    direction).</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>X Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>Y Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>X</Name>
        <Size>16</Size>
        <Description>X-coordinate, or lower byte specifying an
        address for the value if B1 is non-zero.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>Y</Name>
        <Size>16</Size>
        <Description>Y-coordinate, or lower byte specifying an
        address for the value if B2 is non-zero.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>170</Id>
    <Name>MOVA</Name>
    <LongName>Move to Entity</LongName>
    <Description>Moves the field object towards the entity with the
    given ID. Note that this is not a field object ID, in that the
    entity ID includes non-visible entities; in other words, this
    is an offset to an entity in the entire entity list, not just
    the visible entity list. However, attempting to move the field
    object to an entity that is not visible will fail, in that the
    MOVA opcode is ignored.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>E</Name>
        <Size>8</Size>
        <Description>Entity ID to move towards.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>171</Id>
    <Name>TURA</Name>
    <LongName>Turn to entity</LongName>
    <Description>Rotation calculated line in TUGNGEN, except end
    direction calculated during first opcode call. Rotation always
    calculated smoothly. Like in TURNGEN(XX,XX,XX,XX,02); This
    opcode will be called until turn is over and then continue
    script execution.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>E</Name>
        <Size>8</Size>
        <Description>Entity ID to rotate towards,</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>R</Name>
        <Size>16</Size>
        <Description>Specify how model will be rotated. (0 -
        clockwise/ 1 - anti-clockwise/ 2 - closest)</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>S</Name>
        <Size>16</Size>
        <Description>Set number of steps in rotation.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>172</Id>
    <Name>ANIMW</Name>
    <LongName>Wait for Animation</LongName>
    <Description>Waits for the animation to complete that has been
    previously played using any of the animation
    opcodes.</Description>
  </Opcode>
  <Opcode>
    <Id>173</Id>
    <Name>FMOVE</Name>
    <LongName>Move Object (No Animation)</LongName>
    <Description>Similar to MOVE, but the field object won't play
    its animation whilst it moves. Field object will be rotated
    according to movement.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>X Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>Y Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>X</Name>
        <Size>16</Size>
        <Description>X-coordinate, or lower byte specifying an
        address for the value if B1 is non-zero.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>Y</Name>
        <Size>16</Size>
        <Description>Y-coordinate, or lower byte specifying an
        address for the value if B2 is non-zero.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>174</Id>
    <Name>ANIME2</Name>
    <LongName>Animate/Return</LongName>
    <Description>Similarly to ANIME1, the animation specified by A
    is played at speed S for the current entity's field object.
    However, in contrast, the current script's execution is not
    halted whilst the animation is played.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Animation ID for this entity's field
        object.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>S</Name>
        <Size>8</Size>
        <Description>Speed the animation is played at. Real model
        animation speed divide by this to calculate real play
        speed.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>175</Id>
    <Name>ANIM!1</Name>
    <LongName>Wait While Animate/Stay</LongName>
    <Description>Similarly to ANIME1, ANIM!1 plays the animation
    found at ID A in this entity's field object, at the speed
    marked by S. However, when the animation is completed, the
    field object stays posed in the last frame of the animation.
    Script execution is not halted whilst the animation
    plays.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Animation ID for this entity's field
        object.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>S</Name>
        <Size>8</Size>
        <Description>Speed the animation is played at. Higher
        numbers indicate slower animations.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>176</Id>
    <Name>CANIM1</Name>
    <LongName>Particial Animation</LongName>
    <Description>Exactly the same as ANIME2, but allow set first
    and last frame of given animation.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Animation ID for this entity's field
        object.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>F</Name>
        <Size>8</Size>
        <Description>First frame of animation.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>L</Name>
        <Size>8</Size>
        <Description>Last frame of animation.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>S</Name>
        <Size>8</Size>
        <Description>Relative speed of animation. Real model
        animation speed divide by this to calculate real play
        speed.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>177</Id>
    <Name>CANM!1</Name>
    <LongName>Particial Animation</LongName>
    <Description>Exactly the same as ANIM!1, but allow set first
    and last frame of given animation.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Animation ID for this entity's field
        object.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>F</Name>
        <Size>8</Size>
        <Description>First frame of animation.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>L</Name>
        <Size>8</Size>
        <Description>Last frame of animation.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>S</Name>
        <Size>8</Size>
        <Description>Relative speed of animation. Real model
        animation speed divide by this to calculate real play
        speed.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>178</Id>
    <Name>MSPED</Name>
    <LongName>Movement Speed (16-bit)</LongName>
    <Description>Set speed of movement for MOVE-type
    opcodes.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>S Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>S</Name>
        <Size>16</Size>
        <Description>Speed value (8-bit fixed point).</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>179</Id>
    <Name>DIR</Name>
    <LongName>Direction</LongName>
    <Description>Instantaneously turns the field object for this
    entity to the direction specified by D. The direction is in the
    standard direction format for the game.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>D bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>D</Name>
        <Size>8</Size>
        <Description>Direction to face, or address if B is
        non-zero.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>180</Id>
    <Name>TURNGEN</Name>
    <LongName>Generate Turn</LongName>
    <Description>This opcode will be called until turn is over and
    then continue script execution.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>0</Name>
        <Size>4</Size>
        <Description>Zero</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>R Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>R</Name>
        <Size>8</Size>
        <Description>Rotation value to which model will be
        rotated.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>T</Name>
        <Size>8</Size>
        <Description>Specify how model will be rotated. (0 -
        clockwise/ 1 - anti-clockwise/ 2 - closest)</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>S</Name>
        <Size>8</Size>
        <Description>Set number of steps in rotation.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>TS</Name>
        <Size>8</Size>
        <Description>Specify how to calculate rotation step by
        step. (1 - linear/ 2 - smooth.).</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>181</Id>
    <Name>TURN</Name>
    <LongName>Generate Turn</LongName>
    <Description>This is deprecated opcode, only 4 field in game
    use it. This opcode do turn the same way as TURNGEN, but go to
    specify direction without modification. So if current direction
    is 0 (top) and target direction is 255 (top left) it will
    rotate all way clockwise and you can't do anything about 0
    direction. This opcode will be called until turn is over and
    then continue script execution.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>0</Name>
        <Size>4</Size>
        <Description>Zero</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>R Bank</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>182</Id>
    <Name>DIRA</Name>
    <LongName>Direction to Entity</LongName>
    <Description>Instantaneously directs the field object towards
    the entity with the given ID. As with MOVA, the entity ID is an
    offset in the entire entity list, and not into the visible
    object/entities list, and will also have no effect if a
    non-visible entity is given.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>E</Name>
        <Size>8</Size>
        <Description>Entity ID to direct towards.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>183</Id>
    <Name>GETDIR</Name>
    <LongName>Get Entity Direction</LongName>
    <Description>Fetches the direction of the entity given by E
    into bank B, address A. E is an offset into the entity list,
    not a visible object ID, and therefore includes non-visible
    entities; retrieving the direction of a non-visible entity
    results in unusual values being retrieved.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>A Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>E</Name>
        <Size>8</Size>
        <Description>Entity ID</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Address to store direction.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>184</Id>
    <Name>GETAXY</Name>
    <LongName>Get Entity XY</LongName>
    <Description>Fetches the current X- and Y-coordinates of the
    entity given by E into bank B, address A. E is an offset into
    the entity list, not a visible object ID, and therefore
    includes non-visible entities; retrieving the co-ordinates of a
    non-visible entity results in unusual values being
    retrieved.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>X Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>Y Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>E</Name>
        <Size>8</Size>
        <Description>Entity ID to retrieve.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>X</Name>
        <Size>8</Size>
        <Description>Address to store X-coordinate.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>Y</Name>
        <Size>8</Size>
        <Description>Address to store Y-coordinate.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>185</Id>
    <Name>GETAI</Name>
    <LongName>Get Entity Triangle ID</LongName>
    <Description>Fetches the triangle ID on which the object of
    entity E is currently standing on, into bank B, address A. E is
    an offset into the entity list, not a visible object ID, and
    therefore includes non-visible entities; retrieving the
    triangle ID of a non-visible entity results in unusual values
    being retrieved.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>A Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>E</Name>
        <Size>8</Size>
        <Description>Entity ID</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Address to store triangle ID.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>186</Id>
    <Name>ANIM!2</Name>
    <LongName>Animate/Stay</LongName>
    <Description>Similarly to ANIME2, plays the animation found at
    ID A in this entity's field object, at the speed marked by S.
    However, in contrast, the field object stays posed in the last
    frame of the animation played. The current script's execution
    is halted whilst the animation is played, and continues when
    the animation has completed.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Animation ID for this entity's field
        object.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>S</Name>
        <Size>8</Size>
        <Description>Speed the animation is played at. Higher
        numbers indicate slower animations.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>187</Id>
    <Name>CANIM2</Name>
    <LongName>Particial Animation</LongName>
    <Description>Exactly the same as ANIME1, but allow set first
    and last frame of given animation.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Animation ID for this entity's field
        object.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>F</Name>
        <Size>8</Size>
        <Description>First frame of animation.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>L</Name>
        <Size>8</Size>
        <Description>Last frame of animation.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>S</Name>
        <Size>8</Size>
        <Description>Relative speed of animation. Real model
        animation speed divide by this to calculate real play
        speed.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>188</Id>
    <Name>CANM!2</Name>
    <LongName>Particial Animation</LongName>
    <Description>Exactly the same as ANIM!2, but allow set first
    and last frame of given animation.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Animation ID for this entity's field
        object.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>F</Name>
        <Size>8</Size>
        <Description>First frame of animation.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>L</Name>
        <Size>8</Size>
        <Description>Last frame of animation.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>S</Name>
        <Size>8</Size>
        <Description>Relative speed of animation. Real model
        animation speed divide by this to calculate real play
        speed.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>189</Id>
    <Name>ASPED</Name>
    <LongName>Animation Speed</LongName>
    <Description>Set global model animation speed. Lager the value
    - faster all animation played by this model</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>S Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>S</Name>
        <Size>8</Size>
        <Description>Speed of animation</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>190</Id>
    <Name>(unused)</Name>
    <LongName></LongName>
    <Description></Description>
  </Opcode>
  <Opcode>
    <Id>191</Id>
    <Name>CC</Name>
    <LongName>Character Control</LongName>
    <Description>Passes playable character control to the entity
    given. The screen will instantaneously center on the given
    entity's field object, and the player will then be able to
    control the given character around the walkmesh, and if
    currently set to be visible, the 'hand' pointer will hover
    above the specified entity's field object. The entity ID is an
    offset into the entire entity list, not a field object offset;
    attempting to pass control to a non-visible field object will
    have no effect.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>E</Name>
        <Size>8</Size>
        <Description>Entity ID</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>192</Id>
    <Name>JUMP</Name>
    <LongName>Jump</LongName>
    <Description>Causes the character to jump to the specified
    point and triangle ID, with the jump curve peaking at a height
    which is increased by using a larger value for the H argument.
    In addition, the larger the number, the longer the jump will
    take to complete. A "normal" value is around 0x15, 0x01 is fast
    and instantaneous; the argument must not be zero or the game
    will crash. Whilst this is an unsigned two-byte number, a large
    value (beyond around 0x60) will not only cause a vast jump
    height, but also cause the screen to scroll erratically (the
    larger the number, the more erratic). Main update function go
    through all entity with JUMP state and if stage is 0 it
    calculates final Z point according to triangle id. It sets
    current coords as start coords. The main thing this function
    does is set B coefficient for later calculation. It defines as
    follows: B = (Z_final - Z_start) / steps - steps * 1.45; Then
    it set current step to 0 and stage to 1. On next update other
    part of function works. It's calculate real position. First it
    increment current step number. Then it calculate X and Y. They
    change linear so nothing interesting here. Then here we go... Z
    calculation: Z_current = - step^2 * 1.45 + step * B + Z_start;
    If current substep equal number of steps then we set current
    triangle to final triangle and set stage to 2. Which finilize
    routine on next opcode call. Neither animation nor sound is
    specified in this opcode. An animation is played by using an
    animation opcode such as DFANM, and a SOUND played, before the
    jump.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>X Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>Y Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B3</Name>
        <Size>4</Size>
        <Description>I Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B4</Name>
        <Size>4</Size>
        <Description>H Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>X</Name>
        <Size>16</Size>
        <Description>X-coordinate of the target to jump to, or
        lower byte specifying address if B1 is
        non-zero.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>Y</Name>
        <Size>16</Size>
        <Description>Y-coordinate of the target to jump to, or
        lower byte specifying address if B2 is
        non-zero.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>I</Name>
        <Size>16</Size>
        <Description>Triangle ID of the target to jump to, or lower
        byte specifying address if B3 is non-zero.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>H</Name>
        <Size>16</Size>
        <Description>Steps in jump. Must be non-zero if a literal
        value. Alternatively, lower byte specifies address if B4 is
        non-zero.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>193</Id>
    <Name>AXYZI</Name>
    <LongName>Entity Get Position</LongName>
    <Description>Retrieves the coordinates of the field object that
    the entity, whose ID specified in A, is associated with. This
    opcode uses an entity ID, not a field object offset; as such,
    if an entity ID is given that does not have a field object,
    this opcode will store zero in each of the four address
    specified.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>X Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>Y Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B3</Name>
        <Size>4</Size>
        <Description>Z Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B4</Name>
        <Size>4</Size>
        <Description>A Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>E</Name>
        <Size>8</Size>
        <Description>Entity ID whose field object will have its
        position retrieved from.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>X</Name>
        <Size>8</Size>
        <Description>Address to store the X-coordinate of the
        entity's object.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>Y</Name>
        <Size>8</Size>
        <Description>Address to store the Y-coordinate of the
        entity's object.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>Z</Name>
        <Size>8</Size>
        <Description>Address to store the Z-coordinate of the
        entity's object.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Address to store the ID of the walkmesh
        triangle the object is standing on.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>194</Id>
    <Name>LADER</Name>
    <LongName>Ladder</LongName>
    <Description>Causes the character to climb a ladder; that is,
    switching from standard walkmesh movement, to climbing along a
    line connecting two points on the walkmesh. If B1, B2, B3 or B4
    is non-zero, then the value for that particular component is
    taken from memory using the corresponding bank and address
    specified, rather than as a literal value. Both retrieved
    values and literals can be used for different components. If
    using X, Y, Z or I as addresses, the lower byte should hold the
    address whilst the higher byte should be zero. The coordinates
    specify the end-point of the ladder; the current position of
    the character is used as the start point. The ID of the
    walkmesh triangle must be specified; this is the triangle the
    character will step onto after reaching the end point of the
    ladder. The K value specifies the keys used to move the
    character across the ladder; keys outside the range found in
    the table will cause unpredictable behaviour. The animation ID
    specifies an offset into the field object's animation list;
    this animation is played at the speed specified by S whilst the
    character climbs. Finally, the D argument is a direction value
    in the game's standard direction format, which orients the
    character on the ladder. Notes This opcode is used as part of
    the character's entity, rather than in a seperate entity, as
    with a LINE. A LINE is used to set the start point of the
    ladder on the walkmesh. When this LINE is crossed by the
    player, a script in the LINE then uses a PREQ (or one of its
    variants), calling the script in the party leader that defines
    the LADER, causing the character to switch to 'climbing mode'.
    To set up a two-way ladder, two LINEs are used at either end,
    with different values for the LADER arguments, such as
    differing end points. If this opcode is used as part of a
    non-playable character entity, the NPC object will
    automatically climb from the start to the end point without
    need for player interaction.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>X Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>Y Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B3</Name>
        <Size>4</Size>
        <Description>Z Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B4</Name>
        <Size>4</Size>
        <Description>I Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>X</Name>
        <Size>16</Size>
        <Description>X-coordinate of the end of the ladder, or
        address to find X-coordinate if B1 is
        non-zero.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>Y</Name>
        <Size>16</Size>
        <Description>Y-coordinate of the end of the ladder, or
        address to find Y-coordinate if B2 is
        non-zero.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>Z</Name>
        <Size>16</Size>
        <Description>Z-coordinate of the end of the ladder, or
        address to find Z-coordinate if B3 is
        non-zero.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>I</Name>
        <Size>16</Size>
        <Description>ID of the walkmesh triangle found at the end
        of the ladder, or address to find ID if B4 is
        non-zero.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>K</Name>
        <Size>8</Size>
        <Description>The keys used to move the character on the
        ladder. ID Key: Towards the end point Key: Towards the
        start point 0 Down Up 1 Up Down 2 Right Left 3 Left
        Right</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Animation ID for the field object's movement
        animation.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>D</Name>
        <Size>8</Size>
        <Description>Direction the character faces when climbing
        the ladder.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>S</Name>
        <Size>8</Size>
        <Description>Speed of the animation whilst climbing the
        ladder.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>195</Id>
    <Name>OFST</Name>
    <LongName>Offset Object</LongName>
    <Description>Offsets the field object, belonging to the entity
    whose script this opcode resides in, by a certain amount. After
    being offset, the character continues to be constrained in
    movement as defined by the walkmesh's shape, but at a certain
    distance away from the normal walkmesh position. Other field
    objects are unaffected, and their position or movements are
    maintained on the walkmesh's original position. If B1, B2, B3
    or B4 is non-zero, then the value for that particular component
    is taken from memory using the corresponding bank and address
    specified, rather than as a literal value. Both retrieved
    values and literals can be used for different components. If
    using T, X, Y or S as addresses, the lower byte should hold the
    address whilst the higher byte should be zero. The amount to
    offset is specified relative to the current position. If Type
    is specified, the object moves gradually from its current point
    to the offset position; this can be used to simulate movements
    such as elevators. Any type outside the range in the table will
    cause the offset not to occur. If the object is set to move
    gradually, then the speed of offset can be set; the greater the
    number, the slower the object moves to its target offset.
    Script execution may also be halted until the gradual offset
    has been completed. For this, see OFSTW.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>X Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>Y Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B3</Name>
        <Size>4</Size>
        <Description>Z Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B4</Name>
        <Size>4</Size>
        <Description>S Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>T</Name>
        <Size>8</Size>
        <Description>Type of movement. ID Movement Type 0
        Instantaneous 1 Linear (Point-to-point) 2 Quadratic
        (Smoothed)</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>X</Name>
        <Size>16</Size>
        <Description>X offset amount, relative to current position,
        or address to find X offset, if B1 is
        non-zero.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>Y</Name>
        <Size>16</Size>
        <Description>Y offset amount, relative to current position,
        or address to find Y offset, if B2 is
        non-zero.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>Z</Name>
        <Size>16</Size>
        <Description>Z offset amount, relative to current position,
        or address to find Z offset, if B3 is
        non-zero.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>S</Name>
        <Size>16</Size>
        <Description>Speed of the offset movement, if type is
        non-zero, or address to find speed, if B4 is
        non-zero.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>196</Id>
    <Name>OFSTW</Name>
    <LongName>Wait for Offset</LongName>
    <Description>Halts current script execution until a previous
    OFST has completed. This is only of use if the offset type is
    not instantaneous.</Description>
  </Opcode>
  <Opcode>
    <Id>197</Id>
    <Name>TALKR</Name>
    <LongName>Talk Range</LongName>
    <Description>Increases the talk range (or rather, button range)
    for this field object. Larger values mean that the distance
    between the playable character and the field object in question
    is increased, so that the button press script for the object's
    field entity is activated by a button press that is further
    away than normal. For ranges larger than one byte, TLKR2 may be
    used.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>R Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>R</Name>
        <Size>8</Size>
        <Description>Range value</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>198</Id>
    <Name>SLIDR</Name>
    <LongName>Solid Range</LongName>
    <Description>Adjusts the range of the collision circle for the
    entity's field object, changing the distance threshold for
    collisions between the object, and both other objects and the
    walkmesh boundaries. Lower values produce a lower circle for
    the object; higher values increase the circle
    size.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>R Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>R</Name>
        <Size>8</Size>
        <Description>Range value</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>199</Id>
    <Name>SOLID</Name>
    <LongName>Solid object</LongName>
    <Description>Switches the solidity of the field object
    associated with this entity; that is, turns collision detection
    on or off. When off, the playable character will be able to
    walk through the entity's object, as if it were not there. This
    may be used for such objects as save points, where the
    character must be able to walk through the object to be able to
    access the save menu item.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>S</Name>
        <Size>8</Size>
        <Description>Switch on/off (0/1,
        respectively).</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>200</Id>
    <Name>PRTYP</Name>
    <LongName>Party Add</LongName>
    <Description>Adds a character to the party, given by C. The
    character is added in the first given empty party slot (which
    can be set by PRTYE and an argument of FE for a slot). If there
    are no party members, the newly added character is the leader;
    if there is only the leader in the party, the newly added
    character occupies the second slot; if there are two members,
    the character occupies the last remaining slot. If the opcode
    is used when there is already a full party (with three
    members), the newly added party member occupies the last slot,
    overwriting the party member already there.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>C</Name>
        <Size>8</Size>
        <Description>Character ID to add.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>201</Id>
    <Name>PRTYM</Name>
    <LongName>Party Remove</LongName>
    <Description>Moves the specified character out of your party,
    if they are currently in it to begin with. If not, this has no
    effect.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>C</Name>
        <Size>8</Size>
        <Description>Character ID to remove ID Character 0 Cloud 1
        Tifa 2 Barret 3 Aeris 4 Red XIII 5 Yuffie 6 Cait Sith 7 Cid
        8 Vincent</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>202</Id>
    <Name>PRTYE</Name>
    <LongName>Party Change</LongName>
    <Description>Changes the current party to the characters
    specified by each of the three arguments, or leaves the party
    member blank if the ID is 0xFE. Note that the chocobo entry
    will crash during battle, and that Young Cloud and Sephiroth
    occupy the same 'slots' used by Vincent and Cait Sith's
    character entries.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>C1</Name>
        <Size>8</Size>
        <Description>Character ID for first party character ID
        Character 0 Cloud 1 Barret 2 Tifa 3 Aeris 4 Red XIII 5
        Yuffie 6 Cait Sith 7 Vincent 8 Cid 9 Young Cloud A
        Sephiroth B Chocobo FE No character</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>C2</Name>
        <Size>8</Size>
        <Description>Character ID for second party character ID
        Character 0 Cloud 1 Barret 2 Tifa 3 Aeris 4 Red XIII 5
        Yuffie 6 Cait Sith 7 Vincent 8 Cid 9 Young Cloud A
        Sephiroth B Chocobo FE No character</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>C3</Name>
        <Size>8</Size>
        <Description>Character ID for third party character ID
        Character 0 Cloud 1 Barret 2 Tifa 3 Aeris 4 Red XIII 5
        Yuffie 6 Cait Sith 7 Vincent 8 Cid 9 Young Cloud A
        Sephiroth B Chocobo FE No character</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>203</Id>
    <Name>IFPRTYQ</Name>
    <LongName>If Party Member</LongName>
    <Description>Checks whether the character, given as the first
    argument, is in the current party of three. If so, the script
    immediately following this opcode and argument list will
    execute; otherwise, the script pointer is advanced by the
    second argument and execution continues.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>C</Name>
        <Size>8</Size>
        <Description>Character ID to check</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Amount to jump if comparison is
        false</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>204</Id>
    <Name>IFMEMBQ</Name>
    <LongName>If Party Member Available</LongName>
    <Description>Checks whether the character, given as the first
    argument, is globally enabled; that is, the character has been
    enabled using MMBud. If so, the script immediately following
    this opcode and argument list will execute; otherwise, the
    script pointer is advanced by the second argument and execution
    continues.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>C</Name>
        <Size>8</Size>
        <Description>Character ID to check</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Amount to jump if comparison is
        false</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>205</Id>
    <Name>MMBud</Name>
    <LongName>Member Block +/- (Party Select: Character
    Switch)</LongName>
    <Description>Enables or disables the availability of this
    character in the game, as well as in the right-hand selector
    pane in the party select menu. If the character is currently in
    the party, this will have no effect as the character is already
    displayed in the current party list (left pane). This turns the
    character on or off globally. That is, if you turn off the
    character and then query whether the character is available
    with IFMEMBQ, the comparison will not hold, and the script will
    jump to the second argument of IFMEMBQ.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>S</Name>
        <Size>8</Size>
        <Description>Switches the character on/off (1/0,
        respectively).</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>C</Name>
        <Size>8</Size>
        <Description>Character ID whose status will change ID
        Character 0 Cloud 1 Barret 2 Tifa 3 Aeris 4 Red XIII 5
        Yuffie 6 Cait Sith 7 Vincent 8 Cid</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>206</Id>
    <Name>MMBLK</Name>
    <LongName>Party Select: Character Lock</LongName>
    <Description>Locks the character given by the argument in the
    Party Select screen. The player will not be able to move this
    character into or out of the party. The character IDs can be
    found in MMBud. This setting has global scope, that is, the
    character will still be locked when transitioning to a new
    field or to the world map and using the PHS.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>C</Name>
        <Size>8</Size>
        <Description>Character ID to lock.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>207</Id>
    <Name>MMBUK</Name>
    <LongName>Party Select: Character Unlock</LongName>
    <Description>Unlocks the character given by the argument in the
    Party Select screen. The player will be able to move this
    character into or out of the party. The character IDs can be
    found in MMBud. This setting has global scope, that is, the
    character will still be switchable when transitioning to a new
    field or to the world map and using the PHS.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>C</Name>
        <Size>8</Size>
        <Description>Character ID to unlock</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>208</Id>
    <Name>LINE</Name>
    <LongName>Line Definition</LongName>
    <Description>Defines a line on the walkmesh that, when crossed
    by a playable character, causes one of the entity's scripts to
    be executed. These are similar to the triggers in Section 8.
    All the lines in the current field can be turned on or off by
    using the LINON opcode.</Description>
    <Operands>
      <Operand xsi:type="UShort">
        <Name>XA</Name>
        <Size>16</Size>
        <Description>X-coordinate of the first point of the
        line.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>YA</Name>
        <Size>16</Size>
        <Description>Y-coordinate of the first point of the
        line.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>ZA</Name>
        <Size>16</Size>
        <Description>Z-coordinate of the first point of the
        line.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>XB</Name>
        <Size>16</Size>
        <Description>X-coordinate of the second point of the
        line.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>YB</Name>
        <Size>16</Size>
        <Description>Y-coordinate of the second point of the
        line.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>ZB</Name>
        <Size>16</Size>
        <Description>Z-coordinate of the second point of the
        line.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>209</Id>
    <Name>LINON</Name>
    <LongName>Line Switch</LongName>
    <Description>Turns on or off all the LINEs in the current
    field; if set to off, none of the lines will be triggered by
    the character walking through them.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>S</Name>
        <Size>8</Size>
        <Description>Switch on/off (1/0,
        respectively).</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>210</Id>
    <Name>MPJPO</Name>
    <LongName>Gateway Switch (Map Jump Off)</LongName>
    <Description>Turns on or off all the gateways in the current
    field. If set to off, the player will not be able to transition
    to other fields defined by the gateways. MAPJUMP opcodes are
    not affected, and so a combination of LINEs and MAPJUMP could
    still achieve this.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>S</Name>
        <Size>8</Size>
        <Description>Switch on/off (0/1,
        respectively).</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>211</Id>
    <Name>SLINE</Name>
    <LongName>Set Line</LongName>
    <Description>Alters the two points of a previously defined
    LINE. In addition to allowing a line to be adjusted after
    creation, this opcode also provides the ability to retrieve
    line end-point values from memory. If two or more lines are
    defined in one entity, SLINE only updates the first LINE
    definition.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>XA Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>YA Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B3</Name>
        <Size>4</Size>
        <Description>ZA bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B4</Name>
        <Size>4</Size>
        <Description>XB Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B5</Name>
        <Size>4</Size>
        <Description>YB Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B6</Name>
        <Size>4</Size>
        <Description>ZB Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>XA</Name>
        <Size>16</Size>
        <Description>X-coordinate of the first point of the
        line.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>YA</Name>
        <Size>16</Size>
        <Description>Y-coordinate of the first point of the
        line.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>ZA</Name>
        <Size>16</Size>
        <Description>Z-coordinate of the first point of the
        line.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>XB</Name>
        <Size>16</Size>
        <Description>X-coordinate of the second point of the
        line.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>YB</Name>
        <Size>16</Size>
        <Description>Y-coordinate of the second point of the
        line.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>ZB</Name>
        <Size>16</Size>
        <Description>Z-coordinate of the second point of the
        line.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>212</Id>
    <Name>SIN</Name>
    <LongName></LongName>
    <Description></Description>
  </Opcode>
  <Opcode>
    <Id>213</Id>
    <Name>COS</Name>
    <LongName></LongName>
    <Description></Description>
  </Opcode>
  <Opcode>
    <Id>214</Id>
    <Name>TLKR2</Name>
    <LongName>Talk Range (16-bit)</LongName>
    <Description>Similar to TALKR, but allows a two-byte range
    value to be used.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>R Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>R</Name>
        <Size>16</Size>
        <Description>Range value.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>215</Id>
    <Name>SLDR2</Name>
    <LongName>Solid Range (16-bit)</LongName>
    <Description>Similar to SLIDR, but allows a two-byte range
    value to be used.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>R Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UShort">
        <Name>R</Name>
        <Size>16</Size>
        <Description>Range value.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>216</Id>
    <Name>PMJMP</Name>
    <LongName>Prepare Field Change</LongName>
    <Description>Prepare to jump to the field indicated by I. Use
    before making the map jump.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>I</Name>
        <Size>8</Size>
        <Description>Field ID of the map to prepare to jump
        to.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>217</Id>
    <Name>PMJMP2</Name>
    <LongName></LongName>
    <Description></Description>
  </Opcode>
  <Opcode>
    <Id>218</Id>
    <Name>AKAO2</Name>
    <LongName>Sound Operation (word param1)</LongName>
    <Description>Perform an operation described by Op, and uses the
    parameters depending on the operation.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>P1 bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>P2 bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B3</Name>
        <Size>4</Size>
        <Description>P3 bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B4</Name>
        <Size>4</Size>
        <Description>P4 bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>0</Name>
        <Size>4</Size>
        <Description>Zero</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B5</Name>
        <Size>4</Size>
        <Description>P5 bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>O</Name>
        <Size>8</Size>
        <Description>Operation to perform</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>P1</Name>
        <Size>8</Size>
        <Description>Parameter 1</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>P2</Name>
        <Size>8</Size>
        <Description>Parameter 2</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>P3</Name>
        <Size>8</Size>
        <Description>Parameter 3</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>P4</Name>
        <Size>8</Size>
        <Description>Parameter 4</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>P5</Name>
        <Size>8</Size>
        <Description>Parameter 5</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>219</Id>
    <Name>FCFIX</Name>
    <LongName>Character rotatability</LongName>
    <Description>If rotation is locked it will not be changed
    during movement. And some other events. You still can set it
    directly using DIR.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>S</Name>
        <Size>8</Size>
        <Description>1 - lock</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>220</Id>
    <Name>CCANM</Name>
    <LongName>Stand/Walk/Run animation</LongName>
    <Description>Opcode set animation id used for standart player
    action: stand, walk and run. This is global for location so if
    you want to change your player model you need to be sure that
    this model has animation with this id.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Animation ID for selected
        action.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>I</Name>
        <Size>8</Size>
        <Description>Id of selected action. (0 - stand, 1 - walk, 2
        - run)</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>221</Id>
    <Name>ANIMB</Name>
    <LongName>Stop Animation</LongName>
    <Description>Stop current playing animation in the current
    frame (set current frame as last frame). Model will stay in
    this last frame until next animation is not
    activated</Description>
  </Opcode>
  <Opcode>
    <Id>222</Id>
    <Name>TURNW</Name>
    <LongName>Wait for Turn</LongName>
    <Description>Halts execution of the current script for a
    preceding turn to complete. When the object has fully turned,
    execution continues. This works fine, exept TURN, TURNGEN and
    TURA is waitable opcode itself, so this is ignored. Perhaps
    this is deprecated opcode</Description>
  </Opcode>
  <Opcode>
    <Id>223</Id>
    <Name>MPPAL</Name>
    <LongName>Multiply Palette</LongName>
    <Description>Multiply stored palette from start colour by some
    colour</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>Bank for start colour</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>Bank for multiply blue colour</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B3</Name>
        <Size>4</Size>
        <Description>Bank for multiply green colour</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B4</Name>
        <Size>4</Size>
        <Description>Bank for multiply red colour</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>0</Name>
        <Size>4</Size>
        <Description>Zero</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B5</Name>
        <Size>4</Size>
        <Description>Bank for size of palette data</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>O</Name>
        <Size>8</Size>
        <Description>Origin palette array id. Take data from here
        and multiply it by BRG colour.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>D</Name>
        <Size>8</Size>
        <Description>Destination palette array id. Here we store
        data after multiplication</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>C</Name>
        <Size>8</Size>
        <Description>Start colour for multiplication</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>Blue value for multiplying</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>G</Name>
        <Size>8</Size>
        <Description>Green value for multiplying</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>R</Name>
        <Size>8</Size>
        <Description>Red value for multiplying</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>S</Name>
        <Size>8</Size>
        <Description>Size of palette data to multiply +
        1</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>224</Id>
    <Name>BGON</Name>
    <LongName>Background On</LongName>
    <Description>Turns on the portion of background whose
    background sprite belongs to the scripted area and state
    specified. Parts of the background image (or more accurately,
    specific sprites) may be assigned a "scripted area" that allows
    control over that portion of the background by the scripting
    system. Within each scripted area, backgrounds are drawn on top
    of each other in layers, on the same location; these can
    represent a door in both open and closed states, for example,
    allowing the script to switch between an open door when a
    trigger is crossed and a closed door otherwise by simply
    turning off the "closed door" background and turning on the
    "open door" background.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>A Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>L bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>The ID of the background area to manipulate,
        as specified in the background's sprite.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>L</Name>
        <Size>8</Size>
        <Description>The ID of the layer of L to display (turn on),
        as specified in the background's sprite.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>225</Id>
    <Name>BGOFF</Name>
    <LongName>Background Off</LongName>
    <Description>Similar to BGON, only this opcode turns off the
    portion of background whose background sprite specifies it as
    belonging to the scripted area and layer
    specified.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>A Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>L bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>The ID of the background area to manipulate,
        as specified in the background's sprite.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>L</Name>
        <Size>8</Size>
        <Description>The ID of the layer of L to display (turn
        off), as specified in the background's
        sprite.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>226</Id>
    <Name>BGROL</Name>
    <LongName>Background Roll</LongName>
    <Description>Turns on the next numerical layer in the
    background area specified by A. For example, if background area
    3 is currently set to display layer 1 for that particular area,
    a call to BGROL(0,3) will display layer 2 for that area. If an
    invalid layer is given, or the background rolls past the last
    layer for this area, no background is displayed by this
    opcode.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>A Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>The ID of the background area to roll, as
        specified in the background's sprite.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>227</Id>
    <Name>BGROL2</Name>
    <LongName>Background Roll (Reverse)</LongName>
    <Description>Similar to BGROL, except the roll runs backwards
    through layers, rather than forwards. Rolling backwards past
    layer 0 for the area specified results in no background being
    shown.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>A Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>The ID of the background area to roll, as
        specified in the background's sprite.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>228</Id>
    <Name>BGCLR</Name>
    <LongName>Background Clear</LongName>
    <Description>Hides all portions of background whose sprite
    specifies that it belongs to the background area given by
    A.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>A Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>The ID of the background area to clear, as
        specified in the background's sprite, or the address to
        retrieve the value if B is non-zero.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>229</Id>
    <Name>STPAL</Name>
    <LongName>Store Palette</LongName>
    <Description>Stores palette data to special array (0x80095de0
    in english psx version)</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>M Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>P Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>M</Name>
        <Size>8</Size>
        <Description>Id of palette. All palettes stored starting
        from vram_x = 0, vram_y = 0x1e0, so this index is starting
        from vram_y.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>P</Name>
        <Size>8</Size>
        <Description>All palette stored from in special array 0x20
        size of each item. But it just index and can be used lo
        load full 256 colours (it just takes 0x10 slots of
        array).</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>S</Name>
        <Size>8</Size>
        <Description>Size of palette to copy + 1</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>230</Id>
    <Name>LDPAL</Name>
    <LongName>Load Palette</LongName>
    <Description>Load palette from stored array back to
    vram</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>M Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>P Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>M</Name>
        <Size>8</Size>
        <Description>Id of palette. All palettes loaded starting
        from vram_x = 0, vram_y = 0x1e0, so this index is starting
        from vram_y.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>P</Name>
        <Size>8</Size>
        <Description>All palette stored from in special array 0x20
        size of each item. But it just index and can be used lo
        load full 256 colours (it just takes 0x10 slots of
        array).</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>S</Name>
        <Size>8</Size>
        <Description>Size of palette to copy + 1</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>231</Id>
    <Name>CPPAL</Name>
    <LongName>Copy Palette</LongName>
    <Description>Copy palette data.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>O Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>D Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>O</Name>
        <Size>8</Size>
        <Description>Source palette array id to copy data
        from</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>D</Name>
        <Size>8</Size>
        <Description>Destination palette array id to copy data
        to.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>S</Name>
        <Size>8</Size>
        <Description>Size of palette to copy + 1</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>232</Id>
    <Name>RTPAL</Name>
    <LongName></LongName>
    <Description></Description>
  </Opcode>
  <Opcode>
    <Id>233</Id>
    <Name>ADPAL</Name>
    <LongName></LongName>
    <Description></Description>
  </Opcode>
  <Opcode>
    <Id>234</Id>
    <Name>MPPAL2</Name>
    <LongName>Multiply Palette</LongName>
    <Description>Multiply stored palette by some
    colour.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>O Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>D Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B3</Name>
        <Size>4</Size>
        <Description>B Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B4</Name>
        <Size>4</Size>
        <Description>G Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B5</Name>
        <Size>4</Size>
        <Description>R Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>0</Name>
        <Size>4</Size>
        <Description>Zero</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>O</Name>
        <Size>8</Size>
        <Description>Source palette array id to copy data
        from</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>D</Name>
        <Size>8</Size>
        <Description>Destination palette array id to copy data
        to.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>Blue value for multiplying</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>G</Name>
        <Size>8</Size>
        <Description>Green value for multiplying</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>R</Name>
        <Size>8</Size>
        <Description>Red value for multiplying</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>S</Name>
        <Size>8</Size>
        <Description>Size of palette data to multiply +
        1</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>235</Id>
    <Name>STPLS</Name>
    <LongName></LongName>
    <Description></Description>
  </Opcode>
  <Opcode>
    <Id>236</Id>
    <Name>LDPLS</Name>
    <LongName></LongName>
    <Description></Description>
  </Opcode>
  <Opcode>
    <Id>237</Id>
    <Name>CPPAL2</Name>
    <LongName></LongName>
    <Description></Description>
  </Opcode>
  <Opcode>
    <Id>238</Id>
    <Name>RTPAL2</Name>
    <LongName></LongName>
    <Description></Description>
  </Opcode>
  <Opcode>
    <Id>239</Id>
    <Name>ADPAL2</Name>
    <LongName></LongName>
    <Description></Description>
  </Opcode>
  <Opcode>
    <Id>240</Id>
    <Name>MUSIC</Name>
    <LongName>Play Music</LongName>
    <Description>Plays the music that has been defined for the
    field file. Multiple files of music can be set to play in one
    field file, so that they may be switched between during play in
    the field. If the argument is an index beyond the size of the
    list of music files set in the current field file, the game
    will crash.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>I</Name>
        <Size>8</Size>
        <Description>ID for the music file that has been set in the
        field file.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>241</Id>
    <Name>SOUND</Name>
    <LongName>Play Sound</LongName>
    <Description>Plays the sound file indicated by I, or if B1 is
    non-zero, plays the sound with ID found at bank B1 and address
    I. The direction of the sound can also be specified, with 0
    indicating the left speaker and FF indicating the right
    speaker, although for the sound to play at the center, the
    value is at approximately 0x40.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>I Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>D Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>I</Name>
        <Size>8</Size>
        <Description>Sound ID to play, or lower byte indicating
        address and higher byte zero, if B1 is
        non-zero.</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>D</Name>
        <Size>8</Size>
        <Description>Directional sound, or address to find
        direction value, if B2 is non-zero.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>242</Id>
    <Name>AKAO</Name>
    <LongName>Sound Operation (byte param1)</LongName>
    <Description>Perform an operation described by Op, and uses the
    parameters depending on the operation.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B1</Name>
        <Size>4</Size>
        <Description>P1 bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B2</Name>
        <Size>4</Size>
        <Description>P2 bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B3</Name>
        <Size>4</Size>
        <Description>P3 bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B4</Name>
        <Size>4</Size>
        <Description>P4 bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>0</Name>
        <Size>4</Size>
        <Description>Zero</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>B5</Name>
        <Size>4</Size>
        <Description>P5 bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>O</Name>
        <Size>8</Size>
        <Description>Operation to perform</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>P1</Name>
        <Size>8</Size>
        <Description>Parameter 1</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>P2</Name>
        <Size>8</Size>
        <Description>Parameter 2</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>P3</Name>
        <Size>8</Size>
        <Description>Parameter 3</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>P4</Name>
        <Size>8</Size>
        <Description>Parameter 4</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>P5</Name>
        <Size>8</Size>
        <Description>Parameter 5</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>243</Id>
    <Name>MUSVT</Name>
    <LongName></LongName>
    <Description></Description>
  </Opcode>
  <Opcode>
    <Id>244</Id>
    <Name>MUSVM</Name>
    <LongName></LongName>
    <Description></Description>
  </Opcode>
  <Opcode>
    <Id>245</Id>
    <Name>MULCK</Name>
    <LongName>Music Lock</LongName>
    <Description>Locks the MUSIC to the current selection.
    Subsequent calls to change the music will fail unless a
    corresponding MULCK set to 0 is executed.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>S</Name>
        <Size>8</Size>
        <Description>Lock on/off (1/0, respectively).</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>246</Id>
    <Name>BMUSC</Name>
    <LongName>Battle Music</LongName>
    <Description>Sets the MUSIC that will play when the next BATTLE
    is issued. As with the MUSIC opcode, the ID represents an
    offset into the list of music files that have been set by the
    field file. Hence, provided the field file has the correct
    music file(s) set, this opcode can be used to set regular or
    boss battle music for the current field's encounters, or even
    switched between in the script.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>I</Name>
        <Size>8</Size>
        <Description>ID of the music file to play, as set in the
        field file.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>247</Id>
    <Name>CHMPH</Name>
    <LongName></LongName>
    <Description></Description>
  </Opcode>
  <Opcode>
    <Id>248</Id>
    <Name>PMVIE</Name>
    <LongName>Set Movie</LongName>
    <Description>Sets the movie file that will be played at a
    future point in the script by MOVIE.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>M</Name>
        <Size>8</Size>
        <Description>Movie ID to set.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>249</Id>
    <Name>MOVIE</Name>
    <LongName>Play Movie</LongName>
    <Description>Plays the movie previously defined by PMVIE. Note
    that further execution of the current script is halted until
    the movie has finished playing, and a playable character is
    still able to move whilst the movie is being played, so player
    movements may be frozen first. In addition, field music
    currently playing will continue to do so unless explicitly
    instructed otherwise. Note that MOVIE removes the availability
    of the hand pointer above the player's head, even after the
    movie has finished playing. To re-enable it, use SPECIAL:
    POINT.</Description>
  </Opcode>
  <Opcode>
    <Id>250</Id>
    <Name>MVIEF</Name>
    <LongName>Movie Frame</LongName>
    <Description>Stores the frame number of the current MOVIE that
    is being displayed, in the bank and address
    specified.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>A Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Address to store result.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>251</Id>
    <Name>MVCAM</Name>
    <LongName>Movie Camera Switch</LongName>
    <Description>Turns on or off the use of the camera supplied by
    a movie file, that will be played at a future point in the
    script. If off, the field camera remains in use. If set to on,
    the camera defined in the movie file is used, including any
    movement of the camera to match the movie itself.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>S</Name>
        <Size>8</Size>
        <Description>Switch on/off (0/1,
        respectively).</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>252</Id>
    <Name>FMUSC</Name>
    <LongName></LongName>
    <Description></Description>
  </Opcode>
  <Opcode>
    <Id>253</Id>
    <Name>CMUSC</Name>
    <LongName></LongName>
    <Description></Description>
  </Opcode>
  <Opcode>
    <Id>254</Id>
    <Name>CHMST</Name>
    <LongName>Check Music</LongName>
    <Description>Stores a boolean value (0 for false, 1 for true)
    in the bank and address specified, indicating whether music is
    currently playing.</Description>
    <Operands>
      <Operand xsi:type="UByte">
        <Name>B</Name>
        <Size>8</Size>
        <Description>A Bank</Description>
        <Value>0</Value>
      </Operand>
      <Operand xsi:type="UByte">
        <Name>A</Name>
        <Size>8</Size>
        <Description>Address to store result.</Description>
        <Value>0</Value>
      </Operand>
    </Operands>
  </Opcode>
  <Opcode>
    <Id>255</Id>
    <Name>GAMEOVER</Name>
    <LongName>Game over</LongName>
    <Description>Instantaneously ends the current game, displaying
    the 'Game Over' screen; subsequent script commands are not
    executed. As per a normal game over, after the user presses
    [OK], the game returns to the main start menu.</Description>
  </Opcode>
</ArrayOfOpcode>
